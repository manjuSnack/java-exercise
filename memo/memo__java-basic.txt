---

Java의 정석(기초편)

설치와 설정, 에러, 생소한 내용 기술.

---

🍭 #ch1-5~6 자바 개발도구(JDK, Java Development Kit) 설치하기, 설정하기

🍭 Java Eclipse 설치
: JDK 11과 eclipse를 받는다. 실제로는 압축하여 USB 등에 옮겨 작업한다.

🍭 환경 변수 설정
시스템 환경 변수-시스템 변수-Path-jdk경로\bin-확인
: 환경 변수를 맨 위로 올려야 Database 작업 시 충돌 방지.

아래 JAVA_HOME을 먼저 설정한 후 PATH에는 %JAVA_HOME%\bin으로 작성하여도 된다.

시스템 환경 변수-시스템 변수-새로 만들기-JAVA_HOME,
: Tomcat이 JDK가 어디에 있는지 확인하기 위한 변수

Java Install 확인
: cmd ( Command Dos )에서 javac -version으로 java가 잘 설치되었는지 확인할 수 있다. 

만약, Java version과 Java(TM) SE Runtime Environment version이 상이한 경우에는 cmd에서 javac, java 명령어가 작동되지 않는다.

🍭 Java Spring 
Tomcat Install 확인 ( Command Line에서 )
: d: , cd D:\Coding\java\apache-tomcat-9.0.70\bin, startup으로 Tomcat이 잘 설치되었는지 확인할 수 있다.
맨 밑에 startup.Catalina.start ... 가 보이면 브라우저에서 localhost:8080을 가면 Tomcat에 대한 정보가 나온다.

: startup은 Server 열기, shutdown은 Server 닫기

STS도 압축만 풀고 내부에 STS를 실행시키면 된다.
: 만약에 실행과정 화면이 정상적으로 보이지 않으면 환경변수에 문제가 있다.

----

🍭 #ch1-7 자바 API( Application Programing Interface )

: Package 목록, Class 목록으로 All Class에 대한 내용을 참고할 수 있다.

Java API
: https://www.oracle.com/kr/java/technologies/javase-jdk8-doc-downloads.html 에서 다운로드 받는다.

: 경로\jdk-docs-all\docs\api에서 index.html로 Java API에 대한 내용을 알아볼 수 있다.

INDEX
: Java Class에서 method의 이름만 알고 있을 때 검색해 볼 수 있다.

----

🍭 #ch1-8~9 자바 첫 프로그램 작성하기, 자바 프로그램의 실행과정

work 폴더 생성
: 경로\jdk11\에서 work 폴더 생성해 둔다. 이곳에 .java 파일을 저장하는데 꼭 첫 문자는 대문자로 작성한다.

.java 확장자 보이게 하기
: 탐색기 / 파일 / 폴더옵션 / 보기 에서 '알려진 파일 형식의 파일 확장명 숨기기' 해제하고 '모든 폴더에 적용'

🍭 Compile ( javac.exe )

*.java 를 *.class로 기계어로 변환하는 일을 한다.

D:\Coding\java\jdk11\work 경로에서 
: javac 클래스명.java

.java 실행하기
D:\Coding\java\jdk11\work 경로에서 
: java 클래스명로 실행한다.

🍭 type Hello.class와 type Hello.java의 차이
 
: Command Line에서 type Hello.class으로 는 Compile된 기계라 읽기가 어렵지만 type Hello.java는 Code가 적힌 내용을 출력한다.

----

🍭 #ch1-10~12 Eclipse 설치하기, Eclipse로 Java 프로그램 개발하기, Eclipse의 View, Perspective, Workspace

🍭 Download할 Eclipse 종류.

Eclipse IDE for Java EE Developers
: Web Application을 만들 때 사용. 현재 이것으로 설치했다.

Eclipse IDE for Java Developers
: 기본적인 Java 기능만을 제공

Eclipse for Android Developes
: Android Studio를 대신 사용한다.

🍭 Eclipse 내부의 View, Perspective, Workspace

하나의 창을 View라 부르고, 구성 화면 전체를 Perspective(관점)라고 부른다.

Workspace
: Eclipse에서 작성한 파일이 저장되는 공간을 Workspace라고 한다. Eclipse가 처음 열릴 때 확인해 볼 수 있다.

🍭 Build 관련 메뉴 설명

: 소스파일(*.java)로부터 프로그램을 만들어 내는 전 과정

Project -- Build All

: Workspace의 모든 프로젝트를 빌드

Project -- Build Project

: 현재 Project를 Build ( 수동으로 .java를 .class 파일로 Compile 한다. )

Project -- Clean

: 이전 Build의 정보를 모두 삭제 ( 모든 소스 파일을 새로 Compile한다. )

Project -- Build Automatical

: .java File을 변경하고 매 저장할 때마다 .class를 알아서 생성해준다.

🍭 Navigator

탐색기와 같다. Compile 후 *.class를 확인할 수 있다.

Windows -- Show View -- Navigator

----

🍭 ch1-13~16장, Eclipse의 단축키, Eclipse의 자동완성 기능, Eclipse의 주석(Comment), 자주 발생하는 에러와 해결방법

🍭 Ex1_1 참고

ctrl+shift+L : 단축키 전체 목록보기
ctrl+ '+, -' : Font 크기 증가/감소
ctrl+D : 한줄 삭제
ctrl+alt+down : 행단위 복사

alt+shift+A : 멀티컬럼 편집(토글:같은 단축키로 On, Off)
alt+up, down : 선택한 행단위 이동
tab : 들여쓰기
shift+tab : 내어쓰기
ctrl+i : 들여쓰기, 내어쓰기 자동맞춤
ctrl+/ : 주석(토글) 
ctrl+space : 자동완성

🍭 단축키 재설정 방법
: Windows -- Preferences -- General -- Appearance -- Keys-copy line 검색(행단위 복사일 경우) -- Binding 에서 단축키 설정 -- Apply and Close

🍭 자동완성 재설정 방법
Windows -- Preferences -- Java -- Editor -- Templates -- sysout(바꾸고 싶은 자동완성 이름 찾아 선택) -- Edit -- Name 변경(sysout를 sop로 바꿈) -- Rename -- Apply Close

🍭 자동완성 확장 방법
Windows -- Preferences -- Java -- Editor -- Content Assist -- Auto Activation treggers for Java에서 . 를 .abcdefghijklmnopqrstuvwxyz로 바꾸고 저장

----

-- 🍭 #ch01-17~19장 책의 소스와 강의자료 다운로드, Eclipse 소스파일 가져오기, 내보내기

🍭 소스파일 불러오기
Eclipse 좌측 View에 Package Workspace에서 빈공간 우클릭 import-General-Existing Projects into Workspace-Select root directory로 Directory 찾기, Copy projects into workspace 체크(복사본으로 불러오기)

🍭 소스파일 내보내기
Eclipse 좌측 View에 Package Workspace에서 빈공간 우클릭 export-General-Archive file-Export할 Project 선택, to archive file 경로 선택 

---

--🍭 #ch7-12~14 패키지( package ), 패키지의 선언, 클래스 패스( Classpath )

rt.jar
: runtime.jar로 runtime이라는 말 그대로 실행을 담당하는 클래스를 묶어놓은 압축파일. 
Java 9부터는 rt.jar이 아닌 module 개념을 도입하여 사용한다.

🍭 .java 파일이 저장된 탐색기 경로 보기

.java -- context menu -- Show in -- System Explorer

🍭 Class 파일 찾아 실행하기

cmd.exe에서 위의 .java 파일이 저장된 탐색기 경로에 \bin 경로가서 `java <package명.class명>`으로 실행시킬 수 있다.

🍭 환경변수에 CLASSPATH를 등록하기

: 시스템 속성 -- 환경변수 -- CLASSPATH와 경로를 입력하여 만든다. 혹은 cmd.exe에서 `set classpath`를 사용해서 추가한다.

set classpath=<`\bin 경로`>;<추가하고 싶은 경로>

참고로 ` ; `로 여러 경로를 같이 적어줄 수 있다.

---

--🍭 생소한 Method()

print()

println()

printf()

if()

if-else()

switch()

for()
: for ( ; ; )와 for ( ; true; )는 무한루프(infinite loop)이며 for ( 타입 참조변수 : 배열 )은 배열의 값을 하나씩 참조변수에 대입하는 뜻

while()

do-while()

break;

continue;

name : for 또는 while
: 이름붙은 반복문으로 break name; 혹은 continue name;으로 둘 이상의 for문, while문, do-while문을 벗어날 수 있다.

Interger.toBinaryString(숫자) : Integer.toBinaryString()는 값을 2진수로 출력

Integer.parseInt(문자열) : 문자열을 정수로 변환

Double.parseDouble(문자열) : 문자열을 실수로 변환

charAt(0) : 문자열을 문자로 바꿀 수 있다. 예를 들면  변수 Literal.charAt(0) 혹은 "3".charAt(0)으로 '3'으로 바꿀 수 있다.

변수.equals("문자열") : 대소문자 구분하며 변수와 문자열이 같은지 비교한다.

변수.equalsIgnoreCase("문자열") : 대소문자 구분하지 않으며 변수와 문자열을 같은지 비교한다. 

--🍭 Math Class

Math.random() : 난수를 만들어 낸다. 이때 난수는 실수이다.

Math.round() : 실수의 소수점 첫째자리에서 반올림하여 정수로 표현한다.

Math.sqrt(변수)
: 제곱근(√ : root)을 나타낸다.

Math.log(변수)
: 지수함수의 역함수 ( log ), 예를 들어, 3^4 = 81일때, 이때 4가 log이다.

--🍭 Arrays Class -- 배열의 출력, 비교, 복사, 정렬

Arrays.toString(배열)
: 1차원 배열의 모든 요소를 문자열로 변환

Arrays.deepToString(다차원배열)
: 2차원, 다차원 배열의 모든 요소를 문자열로 변환

Arrays.equals( 배열1, 배열2 )
: 1차원 배열1과 배열2의 모든 요소를 비교

Arrays.deepEquals( 배열1, 배열2 )
: 2차원, 다차원 배열1과 배열2의 모든 요소를 비교

타입[ ] 새 배열 = Arrays.copyOf( 복사할 배열, 복사할 배열.length )
: 복사할 배열의 전체 혹 복사할 요소의 갯수만큼 복사해서 새로운 배열에 반환

타입[ ] 새 배열 = Arrays.copyOfRange( 복사할 배열, from, to )
: 복사할 배열을 from ~ to만큼의 범위( index )로 복사해서 새로운 배열에 반환. 단, to의 값-1 만큼만 출력한다.

Arrays.sort( 배열 )
: 배열 내 요소를 오름차순으로 정렬한다.

--🍭 String Class

charAt(int index)
: 문자열에서 해당 위치(index)에 있는 문자를 반환. 배열에서 '배열이름[index]'로 값을 가져오는 것과 같다.

length( )
: 문자열의 길이를 반환

substring(int from, int to)
: 문자열에서 해당 범위(from ~ to)의 문자열을 반환하며 마지막 to에 대한 범위는 포함되지 않는다.

equals(Object obj)
: 문자열의 내용이 같은지 확인한다. 같으면 결과는 true, 다르면 false이다. 또한 대소문자를 구분한다.

equalsIgnoreCase( )
: equals( )와는 다르게 대소문자를 구분하지 않고 문자열의 내용이 같은지 확인한다.

toCharArray( )
: 문자열(String)을 문자배열(Char [ ])로 변환해서 반환한다. 

--🍭 Scanner Class

.nextInt() : 정수를 입력
.nextfloat() : 실수를 입력
.nextLine() : 행단위로 문자열을 입력

--🍭 메모 후 정리중

생성자
: 객체의 초기화

this
: 클래스 내 멤버변수를 참조

this( )
: 클래스 내 생성자를 호출

class 자손클래스 extends 조상클래스
: 조상클래스로부터 멤버변수와 메서드(method)를 상속받는 자손클래스

super
: 상속받은 조상클래스 내 멤버변수를 참조 

super( )
: 상속받은 조상클래스 내 생성자를 호출

Overloading
: 매개변수의 개수와 타입이 다른 같은 이름의 생성자(constructor) 혹 메서드(method)를 정의하는 것

Overriding
: 상속받은 조상클래스 내 메서드를 재정의하는 것 

package 패키지명
: 클래스를 분류해 중복된 이름이 없도록 규정한 클래스의 묶음

import 패키지명.클래스명;
: 클래스이름의 패키지명을 생략하기 위함

import 패키지명.*;
: 해당 패키지 안에 클래스이름의 패키지명을 모두 생략하기 위함 

import static 패키지명.클래스명;
: class 내부의 static class를 import할 때 패키지와 클래스 이름까지 생략하여 사용할 수 있다.

public, protected, (default), private
: 접근제어자( access modifier )를 일컫는다.

static, final, abstract, native, transient, synchronized, volatile, strictfp
: 그 외 제어자( modifier )를 일컫는다.

static
: 인스턴스(객체)를 생성하지 않고도 모든 인스턴스에서 사용할 수 있는 멤버변수와 메서드, 초기화 블록의 앞에 작성한다.

final
: 변경과 상속을 줄 수 없는 클래스, overriding이 불가능한 메서드, 값을 변경할 수 없는 멤버변수와 지역변수의 앞에 작성된다. 그러나 참조된 객체 내부에서의 변경은 가능하다.

abstract
: 인스턴스를 생성할 수 없는 메서드의 선언부만 작성한 실제 수행내용은 구현되지 않은 추상 메서드 혹 추상메서드가 포함된 클래스. 미완성 메서드.
아래 내용 중 abstract class의 설명 참고

---

--💬 추후 학습할 내용!

native ( 본래의 )
: OS가 갖고 있는 메서드로 주로 C언어로 되어있고 이를 Java에서 호출하여 사용. JVM ( Java Virtual Machine ) 밖에서 C/C++ Code로 메소드를 정의할 때 쓰는 키워드
JNI ( Java Native Interface )는 Java와 다른 언어와의 소통할 때 쓰인다. 

transient ( 일시의 )
: Object Stream을 만들 때 값을 전달하지 않도록 숨기는 키워드

synchronized ( 동기화된 )
: 멀티스레드에서 스레드 충돌을 막기 위해 스레드 락(Lock)을 거는 키워드

volatile ( 휘발성의 )
: 컴파일러(Compiler) 최적화를 막아 멀티스레드 처리에 요긴하게 쓰이는 키워드

strictfp ( Strict Floating Point, 엄격한 부동소숫점 )
: 클래스와 인스턴스 내에서 엄격한 부동소숫점 연산을 하도록 하는 키워드. Java 17부터는 영향이 없다.

---

public
: 접근 제한이 없다.

protected
: 같은 패키지 내에서와 더불어 다른 패키지의 자손 클래스에서 접근이 가능하다.

(default)
: 아무 접근 제어자도 작성하지 않은 경우이며 같은 패키지 내에서만 접근이 가능하다. "package-private"라는 이름으로 통용되곤 한다.

private
: 같은 클래스 내에서만 접근이 가능하다.

data hiding
: 외부로부터 접근을 제한하여 데이터가 유효한 값을 유지하도록 하는 것

캡슐화(encapsulation)
: 외부로부터 접근을 제한하거나 외부로 노출시키지 않는 것

get멤버변수이름
: 멤버변수의 값을 읽는 메서드. 간단히 getter라 부른다.

set멤버변수이름
: 멤버변수의 값을 변경하는 메서드. 간단히 setter라 부른다.

다형성(polymorphism)
: Overriding이 대표적인 예시이며, 조상 클래스의 타입과 참조 변수로 자손클래스의 인스턴스를 생성해 참조하여 조상 클래스의 인스턴스 멤버들만 사용가능

쉽게 말해, "부모된 도리로 자식의 밥 숟가락을 뺏지 않는다. 반대의 경우 자식이 시건방지다"

참조변수의 형변환
: 조상 타입의 참조변수로는 조상 클래스의 인스턴스 내 멤버들만 사용 가능
자손 타입 → 조상 타입은 형변환을 생략가능하나 조상 타입 → 자손타입은 생략불가하다. 

쉽게 말해, "할배, 할매 꺼도 내꺼! 엄마, 아빠꺼도 내꺼! 그러나! 내꺼는 내꺼!"

`참조변수 instanceof 타입(클래스명)`
: 참조변수를 형변환이 가능한지 참조변수가 참조하고 있는 인스턴스의 실제 타입을 확인

쉽게 말해, "늬집 자식인지"

매개변수의 다형성
조상타입(조상클래스)의 참조변수를 매개변수(parameter)로 사용하여 자손타입의 객체 내 멤버를 매개변수로 참조하는 것, 
불러올 때에는 자손타입의 객체를 생성하는 문구를 인자(Argument)로 보낸다.

쉽게 말해, "엄마, 아빠가 다 알아서 해줄게"

Vector 클래스
: 배열의 크기를 알아서 관리해주는 클래스

--💬 추후 학습할 내용!
ArrayList와 마찬가지로 배열의 길이를 동적으로 활용할 수 있다는 점은 같지만, Vector는 Thread-block이 구현되어 있다. 
비슷하게 hashtable이 hashMap에 Thread-block 기능이 있으며 최근 버전에서는 Collections.syncronizedCollection, Collections.synchronizedSortedMap 등의 메소드로 내부 구현을 그대로 활용하며 Thread-block 기능을 덧붙일 수 있다.

---

추상클래스( abstract class )
: 상속을 통해 구현하고자 하는 미완성 메서드와 생성자, 멤버변수를 포함하고 있는 클래스이며 따라서 인스턴스는 생성하지 못한다.

쉽게 말해, "후루꾸 클래스"

추상메서드( abstract method )
:  자손클래스에서 상속을 통해 구현하고자 하는 미완성 메서드이며, 구현부가 없기에 { }는 생략한 ` abstract 리턴타입 메서드이름( ); `으로 작성한다.

쉽게 말해, "후루꾸 메서드"

---

인터페이스( interface )
: 오직 추상메서드와 상수만을 멤버로 가질 수 있는 추상화 정도가 높은 추상클래스, 접근제어자(access modifier)로 public 또는 default만을 사용한다. 

작성법
: interface 인터페이스 이름 {
   public static final 타입 상수이름 = 값;
   public abstract 메서드이름(매개변수목록);
}

단, static method와 default method는 앞에 "public abstract"를 쓰지 않아도 된다. JDK 1.8 부터

---

인터페이스의 상속
: 인터페이스는 인터페이스로만 상속이 되며, 클래스와는 달리 다중상속이 가능하다.

class 클래스이름 implements 인터페이스이름 { ... }
: 인터페이스를 상속받은 클래스에서 인터페이스를 구현하며, 인터페이스의 일부만을 구현하고자 할 경우엔 class 앞에 sbstract를 붙여 다시 추상클래스로 선언해야 한다.

class 클래스이름 extends 조상클래스 implements 인터페이스이름 { ... }
: 상속과 구현을 동시에 할 수 있다.

인터페이스의 다형성
: 매개변수의 다형성과 같이 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다. 

리턴타입이 인터페이스라는 것
: 리턴타입이 인터페이스일 경우 메서드 내 해당 인터페이스를 구현한 클래스의 인스턴스가 가진 주소 값을 반환한다. 

인터페이스의 장점
: 하나의 인터페이스로 이를 구현하는 클래스를 동시에 작성할 수 있고 보다 일관된 코드로 정형화시킬 수 있다. 
서로 상속관계에 있지 않은 클래스를 하나의 인터페이스로 간접적인 관계를 맺어 줄 수 있다.

인터페이스에서의 디폴트 메서드(default method)
: 인터페이스에서의 추상 메서드가 아닌 일반 메서드와 역할이 같으며 선언부와 구현부 모두 갖고 있다, "default 리턴타입 메서드이름( ) { ... }"로 작성한다.

여러 인터페이스의 디폴트 메서드 간의 충돌
: 구현한 클래스에서 디폴트 메서드를 오버라이딩한다.

디폴트 메서드와 조상클래스의 메서드 간의 충돌
: 조상 클래스의 메서드만 상속되고 디폴트 메서드는 무시된다.

내부 클래스(inner class)
:  A 내부에 B가 있을 경우 클래스 A를 외부 클래스(outer class), B를 내부 클래스(inner class)라 한다.

내부 클래스의 종류
: 인스턴스 클래스(instance class), 스태틱 클래스(static class), 지역 클래스(local class), 익명 클래스(anonymous class)

인터턴스 클래스, 스태틱 클래스, 지역클래스는 변수의 선언위치와 동일한 유효범위(scope)와 접근성(accessibility)를 갖는다.

익명 클래스(anonymous class)
: 클래스 선언과 객체(인스턴스)의 생성을 동시에 하는 이름없는 클래스. 일회용

---

--🌡 내부 클래스의 제어자와 접근성
: 클래스 앞에는 (default)와 public만 되지만 내부 클래스에서는 private, protected, (default), public이 가능하다.

: JDK1.8의 경우, static 클래스에서만 static 멤버를 정의할 수 있다. 상수인 final static 멤버는 내부 클래스 중 Instance, static, local 클래스 안에 전부에 정의할 수 있다.

: 외부 클래스 내 private 멤버 변수를 내부 클래스에서도 참조할 수 있다.
 
: 외부 클래스의 메서드 내 내부 클래스(지역 클래스)는 지역변수보다 더 오래 존재할 수 있지만, 메서드 수행 뒤엔 지역변수가 사라지며 constant pool에서 상수가 따로 저장되어 final이 붙은 변수(상수)만 접근가능하다.
JDK1.8부터는 final이 생략 가능하므로 지역변수가 상수로 간주된다. 

: Compile한 후 class 파일명은 "외부클래스명$내부클래스명.class" 혹은 "외부클래스$숫자지역클래스.class"로 생성된다. 숫자는 지역클래스 내 같은 이름의 method 순번.

: 내, 외부 클래스에 선언된 변수의 이름이 같을 땐 내부 클래스에는 "this.멤버변수" 로 쓰고 외부클래스에서는 "외부클래스명.this.멤버변수"로 쓴다.

---

익명 클래스(anonymous class)
: 변수와 메서드에는 이름이 있듯이 "그 이름"이 없는 일회용 클래스, 클래스의 선언와 생성을 동시에 한다.

new 조상클래스이름( ) { //멤버선언... } 또는 new 구현인터페이스이름( ) { //멤버선언... }으로 작성한다.

예, 이름이 없기 때문에 조상클래스( )는 Object( )가 된다.

awt ( abstract window toolkit )
: Java의 윈도우 프로그래밍 툴

---

프로그램의 오류란?
: 컴파일 에러(compile-time error), 런타임 에러(runtime error), 논리적 에러(logical error)

컴파일 에러(compile-time error)
: compile 하는 과정 중 발생한 에러

런타임 에러(runtime error)
: 실행도중에 발생하는 에러. 에러(error) 클래스와 예외(exception) 클래스가 있다. 

이때 에러(error) 클래스는 메모리부족(OutOfMemoryError) 혹 스택오버플로우(StackOverflowError)와 같이 일단 발생하면 복구할 수 없는 심각한 오류를 일컫는다.
그러나 예외(exception) 클래스는 수습이 가능하다.

논리적 에러(logical error)
: 의도한 것과 다르게 동작하는 것

Exception과 RuntimeException

: Exception클래스는 사용자의 실수와 같은 외적인 요인의 의한 예외, RuntimeException클래스는 프로그래머의 실수로 발생하는 예외

try-catch문

: 예외처리(exception handling), 예외 발생 시 대비한 코드를 작성하며 비정상 종료를 막고 정상적인 실행상태를 유지한다.
만약 JVM의 예외처리기(UncaughtExceptionHandler)가 처리되지 못한 예외(uncaught exception)가 있다면 이를 받아서 그 원인을 화면에 출력한다.

try-catch문에서의 흐름
: 예외가 없을 경우 catch문 수행은 생략되며 만약 예외 발생 시 일치하는 catch블럭을 확인과 수행, 일치하지 않은 예외가 있는 경우 비정상적인 종료가 발생한다.

예외의 발생과 catch 블럭
: 예외가 발생 시 catch 블럭의 선언부의 예외와 같은 타입의 참조변수에 해당하는 클래스의 인스턴스가 생성되고 instanceof 연산자를 이용하여 검사한 뒤 true인 결과를 얻으면 
catch 블럭 내 구현부를 수행한 후 빠져나온다.

혹시 모를 예외처리 발생으로 여러 catch 블럭 마지막엔 ( Exception e )를 사용.

printStackTrace( )와 getMessage( )
: 예외 발생 원인을 알기 위함. 

printStackTrace( )
: 예외발생 당시의 호출스택( call stack )에 있었던 메서드의 정보와 예외 메시지를 출력

getMessage( )
: 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻어 출력. 기본값은 "/ by zero"이다.

멀티 catch 블럭
: JDK1.7부터 여러 catch 블록을 " | "인 버티컬 라인(vertical line)를 사용하여 여러 예외를 이어 작성할 수 있다. 예외로 조상 클래스와 자식 클래스가 있을 때는 간단히 조상 클래스만 작성.

고의로 예외 발생시키기
: new 연산자로 예외 클래스의 객체(인스턴스)를 생성한 후 이 참조변수를 throw 키워드로 선언 혹 "throw new 예외클래스명"으로 작성하여 예외를 발생시킨다.

checked 예외, unchecked 예외
: Exception 클래스와 그 자손들(checked)은 예외처리(try-catch문)를 강제하며 compile 불가, 
RuntimeException 클래스와 그 자손들(unchecked)은 예외처리(try-catch문) 강제하지 않아 compile 가능하나 runtime 예외는 발생 

메서드에 예외 선언하기
: try-catch문 외에 "void 메서드이름( ) throws Exception1, Exception2, ... ExceptionN { "메서드 내용..." }"로도 작성. 예외의 개수와 상속관계까지 고려해 작성

finally 블럭
: try-catch-finally의 순서로 작성, 실행. 예외 여부에 관계없이 반드시 수행할 수행문을 finally문에 작성

사용자 정의 예외 만들기
: Exception 클래스 혹 RuntimeException을 상속받아 overriding하여 사용자 정의에 맞게 새로운 예외 클래스를 만들 수 있다. RuntimeException을 상속받아 작성하는 추세.

예외 되던지기( exception re-throwing)
: 예외 처리 후 다시 예외를 발생시키는 것, 호출한 호출된 메서드 양쪽 모두에서 예외처리를 하는 것

--🌡 연결된 예외(chained exception)
: 예외 A가 예외 B를 발생시킨 경우, A를 B의 원인 예외(cause exception)이라 한다. 

연결된 예외, 사례 1
: B 예외 안에 A 예외를 포함시켜 간결하게 B 예외만을 catch문 안에 넣을 수 있다. 이때 B 예외는 간략한 정보이고, A 예외는 세부정보에 가깝다. 

연결된 예외, 사례 2
: checked 예외를 unchecked 예외로 바꾸기 위해 쓰인다.

Throwable initCause(Throwable cause)
: 지정한 예외를 원인 예외로 등록

Throwable getCause( )
: 원인 예외를 반환

Throwable
: Exception과 error의 조상 클래스. Throwable 위에 조상클래스는 Obejct 클래스가 있다.

---

--🌡 File Class

new File( filename )
: File 클래스로 "filename"이라는 매개변수를 파일이름으로 가지는 파일 생성

createFile( )
: 파일 생성

copyFiles( )
: 파일 복사

deleteTempFile( )
: 임시파일 삭제

---

java.lang 패키지
: 가장 기본이 되는 클래스의 묶음으로 import문 없이도 사용할 수 있다. Object클래스, String클래스, StringBuffer클래스, Math클래스, Wrapper클래스, Number클래스

Object 클래스
: 모든 클래스의 최고 조상 클래스

protected Object clone( )
: 객체 자신의 복사본을 반환한다. overriding하여 public으로 변경하여 사용

public boolean equals( Object obj )
: 객체 자신과 객체 obj가 같은지 주소 값을 비교. 대부분 iv ( instance value )의 주소 값을 갖고 비교한다. 
주소 값이 아닌 인스턴스의 멤버변수 값을 비교하려면 equals 메서드를 overriding하여 비교한다.

protected void finalize( )
: 객체가 소멸될 때 garbage collector가 자동으로 호출, 이때 수행해야 할 것이 있다면 overriding하여 public으로 변경하여 사용. 
메모리가 부족한 상태일 때 호출되므로 거의 사용하지 않는다. 

public Class getClass( )
: 객체 자신의 클래스 정보를 담고 있는 Class 인스턴스를 반환.

*.java를 Compile하면 *.class가 생성되고 이를 실행시 Class 객체가 생성된다. 이때 객체가 Class 인스턴스.

--🌡 public native int hashCode( ) or public int hashCode( )
: 객체 자신의 해시코드를 반환. 해싱(hashing) 알고리즘 기법에 사용되는 해시함수(hash function)을 구현. 

규칙 
equals( )의 결과가 true인 두 객체의 해시코드가 같아야 하기 때문에, equals( )를 overriding 할 경우 hashCode( )도 overriding하여야 하는 규칙이 있다.
이때 return Objects.hash(멤버변수1, 멤버변수2, ... )로 overriding하며 가변인자(Object..)라서 호출 시 지정하는 값의 개수가 정해져있지 않다.

public static native int identityHashCode(Object x)
: 객체의 주소값의 해시코드를 반환. 모든 객체에 대해 다른 해시코드가 보장

--🌡 hashCode를 64bit JVM인 long 타입( 8 byte )에서 기존 32 bit JVM인 int 타입( 4 byte )으로 변환 시 중복된 값이 도출될 수 있다.

public String toString( )
: 객체 자신의 정보를 문자열로 반환

retrun getClass( ).getName( )+"@"+Integer.toHexString(hashCode( ));가 작성되어 있어 "클래스이름@16진수의해시코드"인 문자열로 표현된다.
toString( ) 메서드를 overrding하여 이를 문자열 표현을 변경해 반환하면 다른 문자열로 표현된다.

public void notify( )
: 객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다.

public void notifyAll( )
: 객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다.

public void wait( )
public void wait( long timeout )
public void wait( long timeout, int nanos )
: 다른 쓰레드가 notify( )나 notifyAll( )을 호출할 때까지 무한히 또는 지정된 시간동안 기다리게 한다. timeout은 천 분의 1초, nanos는 10의 9승 분의 1초

Reflection API
: 객체를 생성하는데 쓰이는 API

---

String 클래스
: 타 언어는 문자열을 char형의 배열로 다루지만 Java는 문자열로 제공한다. 불변(immutable) 클래스이다.

public final class String implements java.io.Serializable, comparable { 
    private char[ ] value;
	...
}

클래스 이름 앞에 final이므로 다른 클래스의 조상이 될 수 없으며 문자열은 읽어 올 수 만 있다. 문자열을 결합, 추출할 경우에는 새로운 String 인스턴스가 생성된다.

StringBuffer 클래스
: 문자열 간의 결합, 추출 작업이 많을 경우 주로 쓰이며 저장된 문자열을 변경할 수 있다.

문자열 생성
: 직접 초기화하는 문자열 리터럴(literal)을 지정하는 방법, new연산자를 통해 String 클래스의 생성자를 사용하는 방법 두가지가 있다.

문자열(String)의 비교
: equals( )는 두 문자열의 내용을 비교하며 등가비교연산자 '=='는 String인스턴스의 주소를 비교하여 결과가 다르다.

--🌡 문자열 리터럴(literal)은 이미 메모리할당이 이뤄진 것을 재사용하므로 등가비교연산자 '=='로도 true의 값을 얻을 수도 있다.

문자열 리터럴(String리터럴)
: 모든 문자열 리터럴은 Compile 시에 클래스 파일에 자동으로 생성되어 저장되며 같은 내용은 한번만 저장된다. 상수와 마찬가지로 constant pool에 저장된다.

빈 문자열(empty string)
: 길이가 0인 배열을 갖고 있는 문자열이 빈 문자열. 예시, String s ="";
char 타입은 하나의 문자가 있어야 한다. Char c = ' ';

---

--🌡 String클래스의 생성자와 메서드 ( p.334 ~ p.336 참고 )

String(String s)
: 주어진 문자열 s를 갖는 String인스턴스 생성

String(char[ ] value)
: 주어진 배열의 문자를 결합한 문자열 value를 갖는 String인스턴스 생성

String(StringBuffer buf)
: StringBuffer인스턴스가 갖고 있는 문자열과 같은 String인스턴스 생성

char charAt(int index)
: 지정된 위치(index)에 문자를 알림

int compareTo(String str)
: 문자열 str과 사전순서로 비교. 같으면 0, 이전 사전순은 음수, 이후 사전순은 양수

String concat(String str)
: 문자열 str을 뒤에 붙인다

boolean contains(CharSequence s)
: 지정된 문자열 s가 포함되었는지 검사

boolean startsWith(String prefix)
: 주어진 문자열 prefix로 시작하는지 검사

boolean endsWith(String suffix)
: 지정된 문자열 suffix로 끝나는지 검사

boolean equals(Object obj)
: Object 클래스 내 설명 참고

boolean equalsIgnoreCase(String str)
: 문자열과 String인스턴스의 문자열을 대소문자 구분없이 비교

int indexOf(int ch)
: 주어진 문자 ch가 문자열에 존재할 경우 위치(index)를 알려준다. 못 찾으면 음수를 반환

int indexOf(int ch, int pos)
: 주어진 문자 ch가 문자열에 존재하는지 지정된 위치 pos부터 확인하여 위치(index)를 알려준다. 못 찾으면 음수를 반환

int indexOf(String str)
: 주어진 문자열 str이 문자열에 존재할 경우 그 위치(index)를 알려준다. 못 찾으면 음수를 반환

String intern( )
: 문자열을 상수풀(constant pool)에 등록, 이미 등록된 경우 주소값을 반환

int lastIndexOf(int ch)
: 지정된 문자 ch 또는 문자코드를 문자열 오른쪽 끝에서 찾아서 위치(index)를 알려준다. 못 찾으면 음수를 반환

int lastIndexOf(String str)
: 지정된 문자열 str을 인스턴스 문자열 끝에서 부터 찾아서 위치(index)를 알려준다. 못 찾으면 음수를 반환

String replace(char old, char nw)
: 문자열 중 문자 old를 새로운 문자 nw로 바꾼 문자열을 반환

String replace(CharSequence old, CharSequence nw)
: 문자열 중 문자열 old를 새로운 문자열 nw로 바꾼 문자열을 반환

String replaceAll(String regex, String replacement)
: 문자열 중에서 지정된 문자열 regex와 일치하는 것을 새로운 문자열 replacement로 모두 변경

String replaceFirst(String regex, String replacement)
: 문자열 중에서 지정된 문자열 regex와 일치하는 것 중 첫번째만을 새로운 문자열 replacement로 변경

String[ ] split(String regex)
: 문자열을 지정된 분리자 regex로 나누어 문자열 배열에 담아 반환

String[ ] split(String regex, int limit)
: 문자열을 지정된 분리자 regex로 나누어 문자열 배열에 담아 반환, 단 문자열 전체 중 지정된 수 limit만큼 자른다.

String substring(int begin)
String substring(int begin, int end)
: 주어진 시작위치 begin부터 끝 위치 end범위에 포함된 문자열을 얻는다. 이때 끝 위치의 문자는 포함되지 않는다. ( begin <= x < end )

String toLowerCase( )
: String인스턴스에 저장된 모든 문자열을 소문자로 변환하여 반환

String toString( )
: Object 클래스 내 설명 참고

String toUpperCase( )
: String인스턴스에 저장된 모든 문자열을 대문자로 변환하여 반환

String trim( )
: 문자열의 왼쪽 끝과 오른쪽 끝에 공백을 없앤 결과를 반환

static String valueOf(boolean b)
static String valueOf(char c)
static String valueOf(int i)
static String valueOf(long l)
static String valueOf(float f)
static String valueOf(double d)
static String valueOf(Object o)
: 지정된 값을 문자열로 변환하여 반환, 참조변수의 경우 toString( )을 호출한 결과를 반환

--🌡 추가 참고

CharSequence
: JDK1.4부터 추가된 인터페이스로 String, StringBuffer 등의 클래스가 구현

: JDK1.5부터 contains(CharSequence s), replace(CharSequence old, CharSequence nw)가 추가

java.util.Date dd = new java.util.Date( )
: 생성된 인스턴스는 현재 시간을 갖는다.

---

join( )과 StringJoiner

join( )
: split( )와 반대로 여러 문자열 사이에 구분자를 넣어서 결합한다. JDK1.8부터 추가

StringJoiner
: 문자열 결합. 아래와 같다.

public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix) 
: 구분자, 접두사(prefix), 접미사(suffix)를 통해 문자열을 결합

문자열과 기본형 간의 변환
: 문자열을 숫자로, 숫자를 문자열로 변환

방법 1
: 빈 문자열 ""을 더해 숫자를 문자열로 바꿀 수 있다.

방법 2
: String.valueOf( 숫자로 된 참조변수 )로 숫자를 문자열로 바꿀 수 있다. 참조변수가 가리키는 인스턴스의 toString( )을 호출해 String을 얻고 결합한다. 

--🌡 문자열 → 기본형

Boolean.parseBoolean(String s)
Byte.parseByte(String s)
Short.parseShort(String s)
Integer.parseInt(String s)
Long.parseLong(String s)
Float.parseFloat(String s)
Double.parseDouble(String s)
: 문자열을 기본형으로 변환. valueOf로도 기본형 → 문자열로, 문자열 → 기본형으로 바꿀 수 있다. valueOf는 Interger 타입이지만 오토박싱(auto-boxing)으로 자동으로 int로 변환된다.

만약, byte, short를 문자열로 변환 시 String valueOf(int i)로 int를 사용하면 된다.

JDK1.7부터 "+"가 포함된 문자열이 parseInt( )로 변환가능

static int parseInt(String a, int radix)
: 16진수 값으로 표현된 문자열도 반환. a의 경우 정수값 10이 반환된다.

StringBuffer클래스와 생성자
: 문자열 변경과 더불어 문자열 길이 조절 가능한 클래스. Buffer의 크기는 기본적으로 16개의 문자를 저장할 수 있는 크기이며 이를 변경할 수 있다.

---

--🌡 StringBuffer의 생성자와 메서드

StringBuffer( )
: 16문자를 담을 수 있는 Buffer를 가진 StringBuffer 인스턴스를 생성

StringBuffer( int length )
: 지정된 개수의 문자를 담을 수 있는 버퍼를 가진 StringBuffer 인스턴스를 생성

StringBuffer( String str )
: 지정된 문자열 값 str를 갖는 StringBuffer 인스턴스를 생성

StringBuffer append(boolean b)
StringBuffer append(char c)
StringBuffer append(char[ ] str)
StringBuffer append(double d)
StringBuffer append(float f)
StringBuffer append(int i)
StringBuffer append(long l)
StringBuffer append(Object obj)
StringBuffer append(String str)
: 매개변수를 문자열로 변환한 뒤 StringBuffer인스턴스가 저장하고 있는 문자열의 뒤에 추가

int capacity( )
: StringBuffer인스턴스의 Buffer의 크기를 알려준다. length( )는 Buffer에 담긴 문자열의 길이를 알려준다.

char charAt(int index)
: 지정된 위치에 있는 문자를 반환

StringBuffer delete(int start, int end)
: 시작위치부터 끝 위치 사이에 문자를 제거, 단 끝 위치의 문자는 제외

StringBuffer deleteCharAt(int index)
: 지정된 위치의 문자를 제거

StringBuffer insert(int pos, boolean b)
StringBuffer insert(int pos, char c)
StringBuffer insert(int pos, char[ ] str)
StringBuffer insert(int pos, double d)
StringBuffer insert(int pos, float f)
StringBuffer insert(int pos, int i)
StringBuffer insert(int pos, Object obj)
StringBuffer insert(int pos, String str)
: 두 번째 매개변수로 문자열을 변환하여 지정한 위치 pos에 추가. 0부터 시작

int length( )
: StringBuffer인스턴스에 저장되어 있는 문자열의 길이를 반환

StringBuffer replace(int start, int end, String str)
: 지정된 범위( start ~ end )의 문자들을 주어진 문자열로 바꾼다. end 위치는 포함되지 않는다 ( start <= x < end )

StringBuffer reverse( )
: StringBuffer인스턴스에 저장되어 있는 문자열의 순서를 거꾸로 나열

void setCharAt(int index, char ch)
: 지정된 위치의 문자를 주어진 문자 ch로 바꾼다.

String toString( )
: StringBuffer인스턴스의 문자열을 String으로 반환

String substring(int start)
String substring(int start, int end)
: 지정된 범위 내 문자열을 String으로 뽑아서 반환. 시작위치 start만을 지정하면 시작위치부터 끝까지 뽑아서 반환.

---

StringBuilder
: StringBuffer에서 쓰레드의 동기화만 뺀 것. StringBuffer는 멀티쓰레드에서 안전(thread safe)하도록 동기화되어 있다. 이 동기화가 StringBuffer의 성능을 떨어뜨린다.

--🌡 참고, 대부분 예제는 싱글 쓰레드로 작성되어 있다.

Math클래스
: 수학계산에 유용한 메서드로 구성

반올림
: 일반적인 계산으로 정수 값에 10의 n제곱으로 곱한 뒤 10의 n제곱만큼의 정수를 .0 붙여 실수로 나누면 원하는 반올림 자리에 수를 얻는다. 

--🌡 Math 메서드

static double abs(double a)
static double abs(float f)
static int abs(int f)
static long abs(long f)
: 주어진 값의 절대값을 반환

static double ceil(double a)
: 주어진 값을 올림하여 반환

static double floor(double a)
: 주어진 값을 버림하여 반환. 음수를 버림하면 더 큰 음수 값으로 반환

static double max(double a, double b)
static float max(float a, float b)
static int max(int a, int b)
static long max(long a, long b)
: 주어진 두 값을 비교하여 큰 쪽을 반환

static double min(double a, double b)
static float min(float a, float b)
static int min(int a, int b)
static long min(long a, long b)
: 주어진 두 값을 비교하여 작은 쪽을 반환

static double random()
: 0.0 ~ 1.0 범위의 임의의 double값을 반환. ( 1.0은 범위에 포함되지 않는다. )

static double rint(double a)
: 주어진 double값을 가장 가까운 정수값을 double형으로 반환. 단, 두 정수의 정가운데 있는 값( 1.5, 2.5, 3.5 ... )는 짝수를 반환

static long round(double a)
static long round(float a)
: 소수점 첫째자리에서 반올림한 정수값 long을 반환. 두 정수의 정가운데 있는 값( 1.5, 2.5 ... )는 항상 큰 정수를 반환

---

래퍼(wrapper) 클래스
: Java는 기본형 타입 8개 ( bit, byte, short, char, int, long, float, double )은 객체로 다루지 않아 완전한 객체지향 언어가 아니라는 이야기도 한다.
이 기본형 타입을 객체로 다루어야 할 때 쓰는 클래스가 래퍼(wrapper) 클래스이다.

--🌡 래퍼(wrapper) 클래스 생성자

-- boolean
Boolean(boolean value)
Boolean(String s)

-- char
Character(char value)

-- byte
Byte(byte value)
Byte(String s)

-- short
Short(short value)
Short(String s)

-- int
Integer(int value)
Integer(String s)

-- long
Long(long value)
Long(String s)

-- float
Float(double value)
Float(float value)
Float(String s)

-- double
Double(double value)
Double(String s)

래퍼클래스별 공통
: static 상수인 MAX_VALUE, MIN_VALUE, SIZE, BYTES, TYPE를 갖고 있다. BYTES는 JDK1.8부터 추가

---

🍭 cmd에서 한글 깨질 경우

chcp ( Changes the active console code page )

chcp 949를 chcp 65001( UTF-8 )로 바꾼다.

> chcp 65001


🍭 *.class의 JDK Version과 JVM Version이 다를 때

java.lang.unsupportedclassversionerror: ~ 와 같은 에러가 발생할 경우, Windows -> Preferences -> Java -> Compiler -> Compiler compliance level: 를 바꾸거나

고급 환경설정에서 JAVA_HOME과 PATH의 내용(경로)를 작성한 *.class의 JDK Version에 맞게 JDK를 설치해 변경한다. 


🍭 Eclipse Setting-@author change

eclipse.ini
: -Duser.name=manjuSnack 추가 혹은 Eclipse에서 Window / Preferences / Java / Code Style / Code Templates / Comments / Types에서

@author ${user}를 @author manjuSnack으로 수정

---

--🍭 Java의 정석 학습과정

--🍭 2023. 02. 18 내용, 1일차

- `Kokoa Clone 다시 만들기` 완성한 이후 Java의 정석 기초편 학습 내용 이후로 학습진행

   : Chapter 6 객체지향언어부터 복습 후 이어 진행. 

- 이전 학습 방법과 다른 방법으로 진행.
   
  : 동영상 강의 우선이 아닌 책 위주로 학습

---

--🍭 2023. 02. 19 내용, 2일차

- 객체지향언어ⅰ / Chapter 6-22 ~ 7-14, 호출스택(call stack) ~ 클래스 패스(classpath)  

---

--🍭 2023. 02. 20 내용, 3일차

- 객체지향언어ⅱ / Chapter 7-15 ~ 7-32, import문 ~ 추상메서드(abstract method)

---

--🍭 2023. 02. 21 내용, 4일차

- 객체지향언어ⅱ / Chapter 7-33 추상클래스의 작성 ~ 예외처리 / Chapter 8-3 Exception과 RuntimeException 

---

--🍭 2023. 02. 22 내용, 5일차

- 예외처리 / Chapter 8-4 예외처리하기(try-catch문) ~ Chapter 8-19 연결된 예외 

---

--🍭 2023. 02. 23 내용, 6일차

- java.lang패키지와 유용한 클래스 / Chapter 9 ~ Chapter 9-13 문자열과 기본형 간의 변환

---

--🍭 2023. 02. 24 내용, 7일차

 - java.lang패키지와 유용한 클래스 / Chpater 9-14 ~ Chapter 9-26 래퍼(wrapper) 클래스