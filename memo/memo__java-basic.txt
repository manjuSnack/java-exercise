---

Java의 정석(기초편)

설치와 설정, 에러, 생소한 내용 기술.

---

🍭 #ch1-5~6 자바 개발도구(JDK, Java Development Kit) 설치하기, 설정하기

🍭 Java Eclipse 설치
: JDK 11과 eclipse를 받는다. 실제로는 압축하여 USB 등에 옮겨 작업한다.

🍭 환경 변수 설정
시스템 환경 변수-시스템 변수-Path-jdk경로\bin-확인
: 환경 변수를 맨 위로 올려야 Database 작업 시 충돌 방지.

아래 JAVA_HOME을 먼저 설정한 후 PATH에는 %JAVA_HOME%\bin으로 작성하여도 된다.

시스템 환경 변수-시스템 변수-새로 만들기-JAVA_HOME,
: Tomcat이 JDK가 어디에 있는지 확인하기 위한 변수

Java Install 확인
: cmd ( Command Dos )에서 javac -version으로 java가 잘 설치되었는지 확인할 수 있다. 

만약, Java version과 Java(TM) SE Runtime Environment version이 상이한 경우에는 cmd에서 javac, java 명령어가 작동되지 않는다.

🍭 Java Spring 
Tomcat Install 확인 ( Command Line에서 )
: d: , cd D:\Coding\java\apache-tomcat-9.0.70\bin, startup으로 Tomcat이 잘 설치되었는지 확인할 수 있다.
맨 밑에 startup.Catalina.start ... 가 보이면 브라우저에서 localhost:8080을 가면 Tomcat에 대한 정보가 나온다.

: startup은 Server 열기, shutdown은 Server 닫기

STS도 압축만 풀고 내부에 STS를 실행시키면 된다.
: 만약에 실행과정 화면이 정상적으로 보이지 않으면 환경변수에 문제가 있다.

🍭 VScode에서의 Java 설치

Extensions -- Extension Pack for Java 설치

설치항목
Language Support for Java(TM) by Red Hat
Debugger for Java
Test Runner for Java
Maven for Java
Project Manager for Java
IntelliCode

--🌡 F1 Key -- Configure Java Runtime에서 알맞은 JDK Version에 골라 설치.



----

🍭 #ch1-7 자바 API( Application Programing Interface )

: Package 목록, Class 목록으로 All Class에 대한 내용을 참고할 수 있다.

Java API
: https://www.oracle.com/kr/java/technologies/javase-jdk8-doc-downloads.html 에서 다운로드 받는다.

: 경로\jdk-docs-all\docs\api에서 index.html로 Java API에 대한 내용을 알아볼 수 있다.

INDEX
: Java Class에서 method의 이름만 알고 있을 때 검색해 볼 수 있다.

----

🍭 #ch1-8~9 자바 첫 프로그램 작성하기, 자바 프로그램의 실행과정

work 폴더 생성
: 경로\jdk11\에서 work 폴더 생성해 둔다. 이곳에 .java 파일을 저장하는데 꼭 첫 문자는 대문자로 작성한다.

.java 확장자 보이게 하기
: 탐색기 / 파일 / 폴더옵션 / 보기 에서 '알려진 파일 형식의 파일 확장명 숨기기' 해제하고 '모든 폴더에 적용'

🥤 Compile ( javac.exe )

*.java 를 *.class로 기계어로 변환하는 일을 한다.

D:\Coding\java\jdk11\work 경로에서 
: javac 클래스명.java

.java 실행하기
D:\Coding\java\jdk11\work 경로에서 
: java 클래스명로 실행한다.

🥤 type Hello.class와 type Hello.java의 차이
 
: Command Line에서 type Hello.class으로 는 Compile된 기계라 읽기가 어렵지만 type Hello.java는 Code가 적힌 내용을 출력한다.
 
🥤 UTF-8로 인코딩하여 Java Compile 하기
: javac 클래스명.java -encoding utf-8

ch12.26 @Deprecated 참고
javac -Xlint:deprecation 클래스명.java -encoding utf-8

----

🍭 #ch1-10~12 Eclipse 설치하기, Eclipse로 Java 프로그램 개발하기, Eclipse의 View, Perspective, Workspace

🍭 Download할 Eclipse 종류.

Eclipse IDE for Java EE Developers
: Web Application을 만들 때 사용. 현재 이것으로 설치했다.

Eclipse IDE for Java Developers
: 기본적인 Java 기능만을 제공

Eclipse for Android Developes
: Android Studio를 대신 사용한다.

🍭 Eclipse 내부의 View, Perspective, Workspace

하나의 창을 View라 부르고, 구성 화면 전체를 Perspective(관점)라고 부른다.

Workspace
: Eclipse에서 작성한 파일이 저장되는 공간을 Workspace라고 한다. Eclipse가 처음 열릴 때 확인해 볼 수 있다.

🍭 Build 관련 메뉴 설명

: 소스파일(*.java)로부터 프로그램을 만들어 내는 전 과정

Project -- Build All

: Workspace의 모든 프로젝트를 빌드

Project -- Build Project

: 현재 Project를 Build ( 수동으로 .java를 .class 파일로 Compile 한다. )

Project -- Clean

: 이전 Build의 정보를 모두 삭제 ( 모든 소스 파일을 새로 Compile한다. )

Project -- Build Automatical

: .java File을 변경하고 매 저장할 때마다 .class를 알아서 생성해준다.

🍭 Navigator

탐색기와 같다. Compile 후 *.class를 확인할 수 있다.

Windows -- Show View -- Navigator

----

🍭 ch1-13~16장, Eclipse의 단축키, Eclipse의 자동완성 기능, Eclipse의 주석(Comment), 자주 발생하는 에러와 해결방법

🍭 Ex1_1 참고

ctrl+shift+L : 단축키 전체 목록보기
ctrl+ '+, -' : Font 크기 증가/감소
ctrl+D : 한줄 삭제
ctrl+alt+down : 행단위 복사

alt+shift+A : 멀티컬럼 편집(토글:같은 단축키로 On, Off)
alt+up, down : 선택한 행단위 이동
tab : 들여쓰기
shift+tab : 내어쓰기
ctrl+i : 들여쓰기, 내어쓰기 자동맞춤
ctrl+/ : 주석(토글) 
ctrl+space : 자동완성

🍭 단축키 재설정 방법
: Windows -- Preferences -- General -- Keys -- 만약, Keys-copy line 검색(행단위 복사일 경우) -- Binding 에서 단축키 설정 -- Apply and Close

🍭 자동완성 재설정 방법
Windows -- Preferences -- Java -- Editor -- Templates -- sysout(바꾸고 싶은 자동완성 이름 찾아 선택) -- Edit -- Name 변경(sysout를 sop로 바꿈) -- Rename -- Apply Close

🍭 자동완성 확장 방법
Windows -- Preferences -- Java -- Editor -- Content Assist -- Auto Activation treggers for Java에서 . 를 .abcdefghijklmnopqrstuvwxyz로 바꾸고 저장

----

-- 🍭 #ch01-17~19장 책의 소스와 강의자료 다운로드, Eclipse 소스파일 가져오기, 내보내기

🍭 소스파일 불러오기
Eclipse 좌측 View에 Package Workspace에서 빈공간 우클릭 import-General-Existing Projects into Workspace-Select root directory로 Directory 찾기, Copy projects into workspace 체크(복사본으로 불러오기)

🍭 소스파일 내보내기
Eclipse 좌측 View에 Package Workspace에서 빈공간 우클릭 export-General-Archive file-Export할 Project 선택, to archive file 경로 선택 

---

--🍭 #ch7-12~14 패키지( package ), 패키지의 선언, 클래스 패스( Classpath )

rt.jar
: runtime.jar로 runtime이라는 말 그대로 실행을 담당하는 클래스를 묶어놓은 압축파일. 
Java 9부터는 rt.jar이 아닌 module 개념을 도입하여 사용한다.

🍭 .java 파일이 저장된 탐색기 경로 보기

.java -- context menu -- Show in -- System Explorer

🍭 Class 파일 찾아 실행하기

cmd.exe에서 위의 .java 파일이 저장된 탐색기 경로에 \bin 경로가서 `java <package명.class명>`으로 실행시킬 수 있다.

🍭 환경변수에 CLASSPATH를 등록하기

: 시스템 속성 -- 환경변수 -- CLASSPATH와 경로를 입력하여 만든다. 혹은 cmd.exe에서 `set classpath`를 사용해서 추가한다.

set classpath=<`\bin 경로`>;<추가하고 싶은 경로>

참고로 ` ; `로 여러 경로를 같이 적어줄 수 있다.

---

--🍭 생소한 Method()

--🌡 화면으로부터 입력받기

String next( )
: 다음 토큰을 문자열로 반환. 빈 문자열인 공백은 반환하지 않는다.

String nextLine( )
: \n을 포함해 읽고 \n을 버린 나머지 문자열을 반환

boolean hasNext( )
: 빈 문자열을 기준으로 끊어 다른 문자열이 있으면 true로 반환. ctrl + z는 입력 종료이므로 false를 반환한다.

boolean hasNextLine( )
: \n을 기준으로 한 줄씩 끊어 문자열이 있으면 true로 반환.  

byte nextByte( )
: 다음 토큰을 byte타입으로 반환

short nextShort( )
: 다음 토큰을 short 타입으로 반환

int nextInt( )
: 다음 토큰을 int 타입으로 반환

long nextLong( )
: 다음 토큰을 long 타입으로 반환

float nextFloat( )
: 다음 토큰을 float 타입으로 반환

double nextDouble( )
: 다음 토큰을 double 타입으로 반환

boolean nextBoolean( )
: 다음 토큰을 boolean 타입으로 반환

void close( )
: Scanner의 사용 종료



print()

println()

printf()

if()

if-else()

switch()

for()
: for ( ; ; )와 for ( ; true; )는 무한루프(infinite loop)이며 for ( 타입 참조변수 : 배열 )은 배열의 값을 하나씩 참조변수에 대입하는 뜻

while()

do-while()

break;

continue;

name : for 또는 while
: 이름붙은 반복문으로 break name; 혹은 continue name;으로 둘 이상의 for문, while문, do-while문을 벗어날 수 있다.

Interger.toBinaryString(숫자) : Integer.toBinaryString()는 값을 2진수로 출력

Integer.parseInt(문자열) : 문자열을 정수로 변환

Double.parseDouble(문자열) : 문자열을 실수로 변환

charAt(0) : 문자열을 문자로 바꿀 수 있다. 예를 들면  변수 Literal.charAt(0) 혹은 "3".charAt(0)으로 '3'으로 바꿀 수 있다.

변수.equals("문자열") : 대소문자 구분하며 변수와 문자열이 같은지 비교한다.

변수.equalsIgnoreCase("문자열") : 대소문자 구분하지 않으며 변수와 문자열을 같은지 비교한다. 

--🍭 Math Class

Math.random() : 난수를 만들어 낸다. 이때 난수는 실수이다.

Math.round() : 실수의 소수점 첫째자리에서 반올림하여 정수로 표현한다.

Math.sqrt(변수)
: 제곱근(√ : root)을 나타낸다.

Math.log(변수)
: 지수함수의 역함수 ( log ), 예를 들어, 3^4 = 81일때, 이때 4가 log이다.

--🍭 Arrays Class -- 배열의 출력, 비교, 복사, 정렬

Arrays.toString(배열)
: 1차원 배열의 모든 요소를 문자열로 변환

Arrays.deepToString(다차원배열)
: 2차원, 다차원 배열의 모든 요소를 문자열로 변환

Arrays.equals( 배열1, 배열2 )
: 1차원 배열1과 배열2의 모든 요소를 비교

Arrays.deepEquals( 배열1, 배열2 )
: 2차원, 다차원 배열1과 배열2의 모든 요소를 비교

타입[ ] 새 배열 = Arrays.copyOf( 복사할 배열, 복사할 배열.length )
: 복사할 배열의 전체 혹 복사할 요소의 갯수만큼 복사해서 새로운 배열에 반환

타입[ ] 새 배열 = Arrays.copyOfRange( 복사할 배열, from, to )
: 복사할 배열을 from ~ to만큼의 범위( index )로 복사해서 새로운 배열에 반환. 단, to의 값-1 만큼만 출력한다.

Arrays.sort( 배열 )
: 배열 내 요소를 오름차순으로 정렬한다.

--🍭 String Class

charAt(int index)
: 문자열에서 해당 위치(index)에 있는 문자를 반환. 배열에서 '배열이름[index]'로 값을 가져오는 것과 같다.

length( )
: 문자열의 길이를 반환

substring(int from, int to)
: 문자열에서 해당 범위(from ~ to)의 문자열을 반환하며 마지막 to에 대한 범위는 포함되지 않는다.

equals(Object obj)
: 문자열의 내용이 같은지 확인한다. 같으면 결과는 true, 다르면 false이다. 또한 대소문자를 구분한다.

equalsIgnoreCase( )
: equals( )와는 다르게 대소문자를 구분하지 않고 문자열의 내용이 같은지 확인한다.

toCharArray( )
: 문자열(String)을 문자배열(Char [ ])로 변환해서 반환한다. 

--🍭 Scanner Class

.nextInt() : 정수를 입력
.nextfloat() : 실수를 입력
.nextLine() : 행단위로 문자열을 입력

--🍭 메모 후 정리중

생성자
: 객체의 초기화

this
: 클래스 내 멤버변수를 참조

this( )
: 클래스 내 생성자를 호출

class 자손클래스 extends 조상클래스
: 조상클래스로부터 멤버변수와 메서드(method)를 상속받는 자손클래스

super
: 상속받은 조상클래스 내 멤버변수를 참조 

super( )
: 상속받은 조상클래스 내 생성자를 호출

Overloading
: 매개변수의 개수와 타입이 다른 같은 이름의 생성자(constructor) 혹 메서드(method)를 정의하는 것

Overriding
: 상속받은 조상클래스 내 메서드를 재정의하는 것 

package 패키지명
: 클래스를 분류해 중복된 이름이 없도록 규정한 클래스의 묶음

import 패키지명.클래스명;
: 클래스이름의 패키지명을 생략하기 위함

import 패키지명.*;
: 해당 패키지 안에 클래스이름의 패키지명을 모두 생략하기 위함 

import static 패키지명.클래스명;
: class 내부의 static class를 import할 때 패키지와 클래스 이름까지 생략하여 사용할 수 있다.

public, protected, (default), private
: 접근제어자( access modifier )를 일컫는다.

static, final, abstract, native, transient, synchronized, volatile, strictfp
: 그 외 제어자( modifier )를 일컫는다.

static
: 인스턴스(객체)를 생성하지 않고도 모든 인스턴스에서 사용할 수 있는 멤버변수와 메서드, 초기화 블록의 앞에 작성한다.

final
: 변경과 상속을 줄 수 없는 클래스, overriding이 불가능한 메서드, 값을 변경할 수 없는 멤버변수와 지역변수의 앞에 작성된다. 그러나 참조된 객체 내부에서의 변경은 가능하다.

abstract
: 인스턴스를 생성할 수 없는 메서드의 선언부만 작성한 실제 수행내용은 구현되지 않은 추상 메서드 혹 추상메서드가 포함된 클래스. 미완성 메서드.
아래 내용 중 abstract class의 설명 참고

---

--💬 추후 학습할 내용!

native ( 본래의 )
: OS가 갖고 있는 메서드로 주로 C언어로 되어있고 이를 Java에서 호출하여 사용. JVM ( Java Virtual Machine ) 밖에서 C/C++ Code로 메소드를 정의할 때 쓰는 키워드
JNI ( Java Native Interface )는 Java와 다른 언어와의 소통할 때 쓰인다. 

transient ( 일시의 )
: Object Stream을 만들 때 값을 전달하지 않도록 숨기는 키워드

synchronized ( 동기화된 )
: 멀티스레드에서 스레드 충돌을 막기 위해 스레드 락(Lock)을 거는 키워드

volatile ( 휘발성의 )
: 컴파일러(Compiler) 최적화를 막아 멀티스레드 처리에 요긴하게 쓰이는 키워드

strictfp ( Strict Floating Point, 엄격한 부동소숫점 )
: 클래스와 인스턴스 내에서 엄격한 부동소숫점 연산을 하도록 하는 키워드. Java 17부터는 영향이 없다.

---

public
: 접근 제한이 없다.

protected
: 같은 패키지 내에서와 더불어 다른 패키지의 자손 클래스에서 접근이 가능하다.

(default)
: 아무 접근 제어자도 작성하지 않은 경우이며 같은 패키지 내에서만 접근이 가능하다. "package-private"라는 이름으로 통용되곤 한다.

private
: 같은 클래스 내에서만 접근이 가능하다.

data hiding
: 외부로부터 접근을 제한하여 데이터가 유효한 값을 유지하도록 하는 것

캡슐화(encapsulation)
: 외부로부터 접근을 제한하거나 외부로 노출시키지 않는 것

get멤버변수이름
: 멤버변수의 값을 읽는 메서드. 간단히 getter라 부른다.

set멤버변수이름
: 멤버변수의 값을 변경하는 메서드. 간단히 setter라 부른다.

다형성(polymorphism)
: Overriding이 대표적인 예시이며, 조상 클래스의 타입과 참조 변수로 자손클래스의 인스턴스를 생성해 참조하여 조상 클래스의 인스턴스 멤버들만 사용가능

쉽게 말해, "부모된 도리로 자식의 밥 숟가락을 뺏지 않는다. 반대의 경우 자식이 시건방지다"

참조변수의 형변환
: 조상 타입의 참조변수로는 조상 클래스의 인스턴스 내 멤버들만 사용 가능
자손 타입 → 조상 타입은 형변환을 생략가능하나 조상 타입 → 자손타입은 생략불가하다. 

쉽게 말해, "할배, 할매 꺼도 내꺼! 엄마, 아빠꺼도 내꺼! 그러나! 내꺼는 내꺼!"

`참조변수 instanceof 타입(클래스명)`
: 참조변수를 형변환이 가능한지 참조변수가 참조하고 있는 인스턴스의 실제 타입을 확인

쉽게 말해, "늬집 자식인지"

매개변수의 다형성
조상타입(조상클래스)의 참조변수를 매개변수(parameter)로 사용하여 자손타입의 객체 내 멤버를 매개변수로 참조하는 것, 
불러올 때에는 자손타입의 객체를 생성하는 문구를 인자(Argument)로 보낸다.

쉽게 말해, "엄마, 아빠가 다 알아서 해줄게"

Vector 클래스
: 배열의 크기를 알아서 관리해주는 클래스

--💬 추후 학습할 내용!
ArrayList와 마찬가지로 배열의 길이를 동적으로 활용할 수 있다는 점은 같지만, Vector는 Thread-block이 구현되어 있다. 
비슷하게 hashtable이 hashMap에 Thread-block 기능이 있으며 최근 버전에서는 Collections.syncronizedCollection, Collections.synchronizedSortedMap 등의 메소드로 내부 구현을 그대로 활용하며 Thread-block 기능을 덧붙일 수 있다.

---

추상클래스( abstract class )
: 상속을 통해 구현하고자 하는 미완성 메서드와 생성자, 멤버변수를 포함하고 있는 클래스이며 따라서 인스턴스는 생성하지 못한다.

쉽게 말해, "후루꾸 클래스"

추상메서드( abstract method )
:  자손클래스에서 상속을 통해 구현하고자 하는 미완성 메서드이며, 구현부가 없기에 { }는 생략한 ` abstract 리턴타입 메서드이름( ); `으로 작성한다.

쉽게 말해, "후루꾸 메서드"

---

인터페이스( interface )
: 오직 추상메서드와 상수만을 멤버로 가질 수 있는 추상화 정도가 높은 추상클래스, 접근제어자(access modifier)로 public 또는 default만을 사용한다. 

작성법
: interface 인터페이스 이름 {
   public static final 타입 상수이름 = 값;
   public abstract 메서드이름(매개변수목록);
}

단, static method와 default method는 앞에 "public abstract"를 쓰지 않아도 된다. JDK 1.8 부터

---

인터페이스의 상속
: 인터페이스는 인터페이스로만 상속이 되며, 클래스와는 달리 다중상속이 가능하다.

class 클래스이름 implements 인터페이스이름 { ... }
: 인터페이스를 상속받은 클래스에서 인터페이스를 구현하며, 인터페이스의 일부만을 구현하고자 할 경우엔 class 앞에 sbstract를 붙여 다시 추상클래스로 선언해야 한다.

class 클래스이름 extends 조상클래스 implements 인터페이스이름 { ... }
: 상속과 구현을 동시에 할 수 있다.

인터페이스의 다형성
: 매개변수의 다형성과 같이 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다. 

리턴타입이 인터페이스라는 것
: 리턴타입이 인터페이스일 경우 메서드 내 해당 인터페이스를 구현한 클래스의 인스턴스가 가진 주소 값을 반환한다. 

인터페이스의 장점
: 하나의 인터페이스로 이를 구현하는 클래스를 동시에 작성할 수 있고 보다 일관된 코드로 정형화시킬 수 있다. 
서로 상속관계에 있지 않은 클래스를 하나의 인터페이스로 간접적인 관계를 맺어 줄 수 있다.

인터페이스에서의 디폴트 메서드(default method)
: 인터페이스에서의 추상 메서드가 아닌 일반 메서드와 역할이 같으며 선언부와 구현부 모두 갖고 있다, "default 리턴타입 메서드이름( ) { ... }"로 작성한다.

여러 인터페이스의 디폴트 메서드 간의 충돌
: 구현한 클래스에서 디폴트 메서드를 오버라이딩한다.

디폴트 메서드와 조상클래스의 메서드 간의 충돌
: 조상 클래스의 메서드만 상속되고 디폴트 메서드는 무시된다.

내부 클래스(inner class)
:  A 내부에 B가 있을 경우 클래스 A를 외부 클래스(outer class), B를 내부 클래스(inner class)라 한다.

내부 클래스의 종류
: 인스턴스 클래스(instance class), 스태틱 클래스(static class), 지역 클래스(local class), 익명 클래스(anonymous class)

인터턴스 클래스, 스태틱 클래스, 지역클래스는 변수의 선언위치와 동일한 유효범위(scope)와 접근성(accessibility)를 갖는다.

익명 클래스(anonymous class)
: 클래스 선언과 객체(인스턴스)의 생성을 동시에 하는 이름없는 클래스. 일회용

---

--🌡 내부 클래스의 제어자와 접근성
: 클래스 앞에는 (default)와 public만 되지만 내부 클래스에서는 private, protected, (default), public이 가능하다.

: JDK1.8의 경우, static 클래스에서만 static 멤버를 정의할 수 있다. 상수인 final static 멤버는 내부 클래스 중 Instance, static, local 클래스 안에 전부에 정의할 수 있다.

: 외부 클래스 내 private 멤버 변수를 내부 클래스에서도 참조할 수 있다.
 
: 외부 클래스의 메서드 내 내부 클래스(지역 클래스)는 지역변수보다 더 오래 존재할 수 있지만, 메서드 수행 뒤엔 지역변수가 사라지며 constant pool에서 상수가 따로 저장되어 final이 붙은 변수(상수)만 접근가능하다.
JDK1.8부터는 final이 생략 가능하므로 지역변수가 상수로 간주된다. 

: Compile한 후 class 파일명은 "외부클래스명$내부클래스명.class" 혹은 "외부클래스$숫자지역클래스.class"로 생성된다. 숫자는 지역클래스 내 같은 이름의 method 순번.

: 내, 외부 클래스에 선언된 변수의 이름이 같을 땐 내부 클래스에는 "this.멤버변수" 로 쓰고 외부클래스에서는 "외부클래스명.this.멤버변수"로 쓴다.

---

익명 클래스(anonymous class)
: 변수와 메서드에는 이름이 있듯이 "그 이름"이 없는 일회용 클래스, 클래스의 선언와 생성을 동시에 한다.

new 조상클래스이름( ) { //멤버선언... } 또는 new 구현인터페이스이름( ) { //멤버선언... }으로 작성한다.

예, 이름이 없기 때문에 조상클래스( )는 Object( )가 된다.

awt ( abstract window toolkit )
: Java의 윈도우 프로그래밍 툴

---

프로그램의 오류란?
: 컴파일 에러(compile-time error), 런타임 에러(runtime error), 논리적 에러(logical error)

컴파일 에러(compile-time error)
: compile 하는 과정 중 발생한 에러

런타임 에러(runtime error)
: 실행도중에 발생하는 에러. 에러(error) 클래스와 예외(exception) 클래스가 있다. 

이때 에러(error) 클래스는 메모리부족(OutOfMemoryError) 혹 스택오버플로우(StackOverflowError)와 같이 일단 발생하면 복구할 수 없는 심각한 오류를 일컫는다.
그러나 예외(exception) 클래스는 수습이 가능하다.

논리적 에러(logical error)
: 의도한 것과 다르게 동작하는 것

Exception과 RuntimeException

: Exception클래스는 사용자의 실수와 같은 외적인 요인의 의한 예외, RuntimeException클래스는 프로그래머의 실수로 발생하는 예외

try-catch문

: 예외처리(exception handling), 예외 발생 시 대비한 코드를 작성하며 비정상 종료를 막고 정상적인 실행상태를 유지한다.
만약 JVM의 예외처리기(UncaughtExceptionHandler)가 처리되지 못한 예외(uncaught exception)가 있다면 이를 받아서 그 원인을 화면에 출력한다.

try-catch문에서의 흐름
: 예외가 없을 경우 catch문 수행은 생략되며 만약 예외 발생 시 일치하는 catch블럭을 확인과 수행, 일치하지 않은 예외가 있는 경우 비정상적인 종료가 발생한다.

예외의 발생과 catch 블럭
: 예외가 발생 시 catch 블럭의 선언부의 예외와 같은 타입의 참조변수에 해당하는 클래스의 인스턴스가 생성되고 instanceof 연산자를 이용하여 검사한 뒤 true인 결과를 얻으면 
catch 블럭 내 구현부를 수행한 후 빠져나온다.

혹시 모를 예외처리 발생으로 여러 catch 블럭 마지막엔 ( Exception e )를 사용.

printStackTrace( )와 getMessage( )
: 예외 발생 원인을 알기 위함. 

printStackTrace( )
: 예외발생 당시의 호출스택( call stack )에 있었던 메서드의 정보와 예외 메시지를 출력

getMessage( )
: 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻어 출력. 기본값은 "/ by zero"이다.

멀티 catch 블럭
: JDK1.7부터 여러 catch 블록을 " | "인 버티컬 라인(vertical line)를 사용하여 여러 예외를 이어 작성할 수 있다. 예외로 조상 클래스와 자식 클래스가 있을 때는 간단히 조상 클래스만 작성.

고의로 예외 발생시키기
: new 연산자로 예외 클래스의 객체(인스턴스)를 생성한 후 이 참조변수를 throw 키워드로 선언 혹 "throw new 예외클래스명"으로 작성하여 예외를 발생시킨다.

checked 예외, unchecked 예외
: Exception 클래스와 그 자손들(checked)은 예외처리(try-catch문)를 강제하며 compile 불가, 
RuntimeException 클래스와 그 자손들(unchecked)은 예외처리(try-catch문) 강제하지 않아 compile 가능하나 runtime 예외는 발생 

메서드에 예외 선언하기
: try-catch문 외에 "void 메서드이름( ) throws Exception1, Exception2, ... ExceptionN { "메서드 내용..." }"로도 작성. 예외의 개수와 상속관계까지 고려해 작성

finally 블럭
: try-catch-finally의 순서로 작성, 실행. 예외 여부에 관계없이 반드시 수행할 수행문을 finally문에 작성

사용자 정의 예외 만들기
: Exception 클래스 혹 RuntimeException을 상속받아 overriding하여 사용자 정의에 맞게 새로운 예외 클래스를 만들 수 있다. RuntimeException을 상속받아 작성하는 추세.

예외 되던지기( exception re-throwing)
: 예외 처리 후 다시 예외를 발생시키는 것, 호출한 호출된 메서드 양쪽 모두에서 예외처리를 하는 것

--🌡 연결된 예외(chained exception)
: 예외 A가 예외 B를 발생시킨 경우, A를 B의 원인 예외(cause exception)이라 한다. 

연결된 예외, 사례 1
: B 예외 안에 A 예외를 포함시켜 간결하게 B 예외만을 catch문 안에 넣을 수 있다. 이때 B 예외는 간략한 정보이고, A 예외는 세부정보에 가깝다. 

연결된 예외, 사례 2
: checked 예외를 unchecked 예외로 바꾸기 위해 쓰인다.

Throwable initCause(Throwable cause)
: 지정한 예외를 원인 예외로 등록

Throwable getCause( )
: 원인 예외를 반환

Throwable
: Exception과 error의 조상 클래스. Throwable 위에 조상클래스는 Obejct 클래스가 있다.

---

--🌡 File Class

new File( filename )
: File 클래스로 "filename"이라는 매개변수를 파일이름으로 가지는 파일 생성

createFile( )
: 파일 생성

copyFiles( )
: 파일 복사

deleteTempFile( )
: 임시파일 삭제

---

java.lang 패키지
: 가장 기본이 되는 클래스의 묶음으로 import문 없이도 사용할 수 있다. Object클래스, String클래스, StringBuffer클래스, Math클래스, Wrapper클래스, Number클래스

🥤 Class 객체 ( 12.39 애너테이션의 활용에서 참고 )
: Class<Ex12_8> cls = Ex12_8.class 에서
'Ex12_8.class'는 클래스 객체를 의미하는 리터럴이다, 클래스 파일은 클래스 로더(Class loader)에 의해 메모리에 올라갈 때, 클래스에 대한 정보가 담긴 객체를 생성하는데 이를 
클래스 객체라고 한다.


Object 클래스
: 모든 클래스의 최고 조상 클래스

protected Object clone( )
: 객체 자신의 복사본을 반환한다. overriding하여 public으로 변경하여 사용

public boolean equals( Object obj )
: 객체 자신과 객체 obj가 같은지 주소 값을 비교. 대부분 iv ( instance value )의 주소 값을 갖고 비교한다. 
주소 값이 아닌 인스턴스의 멤버변수 값을 비교하려면 equals 메서드를 overriding하여 비교한다.

protected void finalize( )
: 객체가 소멸될 때 garbage collector가 자동으로 호출, 이때 수행해야 할 것이 있다면 overriding하여 public으로 변경하여 사용. 
메모리가 부족한 상태일 때 호출되므로 거의 사용하지 않는다. 

public Class getClass( )
: 객체 자신의 클래스 정보를 담고 있는 Class 인스턴스를 반환.

*.java를 Compile하면 *.class가 생성되고 이를 실행시 Class 객체가 생성된다. 이때 객체가 Class 인스턴스.

--🌡 public native int hashCode( ) or public int hashCode( )
: 객체 자신의 해시코드를 반환. 해싱(hashing) 알고리즘 기법에 사용되는 해시함수(hash function)을 구현. 

규칙 
equals( )의 결과가 true인 두 객체의 해시코드가 같아야 하기 때문에, equals( )를 overriding 할 경우 hashCode( )도 overriding하여야 하는 규칙이 있다.
이때 return Objects.hash(멤버변수1, 멤버변수2, ... )로 overriding하며 가변인자(Object..)라서 호출 시 지정하는 값의 개수가 정해져있지 않다.

public static native int identityHashCode(Object x)
: 객체의 주소값의 해시코드를 반환. 모든 객체에 대해 다른 해시코드가 보장

--🌡 hashCode를 64bit JVM인 long 타입( 8 byte )에서 기존 32 bit JVM인 int 타입( 4 byte )으로 변환 시 중복된 값이 도출될 수 있다.

public String toString( )
: 객체 자신의 정보를 문자열로 반환

retrun getClass( ).getName( )+"@"+Integer.toHexString(hashCode( ));가 작성되어 있어 "클래스이름@16진수의해시코드"인 문자열로 표현된다.
toString( ) 메서드를 overrding하여 이를 문자열 표현을 변경해 반환하면 다른 문자열로 표현된다.

public void notify( )
: 객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다.

public void notifyAll( )
: 객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다.

public void wait( )
public void wait( long timeout )
public void wait( long timeout, int nanos )
: 다른 쓰레드가 notify( )나 notifyAll( )을 호출할 때까지 무한히 또는 지정된 시간동안 기다리게 한다. timeout은 천 분의 1초, nanos는 10의 9승 분의 1초

Reflection API
: 객체를 생성하는데 쓰이는 API

---

String 클래스
: 타 언어는 문자열을 char형의 배열로 다루지만 Java는 문자열로 제공한다. 불변(immutable) 클래스이다.

public final class String implements java.io.Serializable, comparable { 
    private char[ ] value;
	...
}

클래스 이름 앞에 final이므로 다른 클래스의 조상이 될 수 없으며 문자열은 읽어 올 수 만 있다. 문자열을 결합, 추출할 경우에는 새로운 String 인스턴스가 생성된다.

StringBuffer 클래스
: 문자열 간의 결합, 추출 작업이 많을 경우 주로 쓰이며 저장된 문자열을 변경할 수 있다.

문자열 생성
: 직접 초기화하는 문자열 리터럴(literal)을 지정하는 방법, new연산자를 통해 String 클래스의 생성자를 사용하는 방법 두가지가 있다.

문자열(String)의 비교
: equals( )는 두 문자열의 내용을 비교하며 등가비교연산자 '=='는 String인스턴스의 주소를 비교하여 결과가 다르다.

--🌡 문자열 리터럴(literal)은 이미 메모리할당이 이뤄진 것을 재사용하므로 등가비교연산자 '=='로도 true의 값을 얻을 수도 있다.

문자열 리터럴(String리터럴)
: 모든 문자열 리터럴은 Compile 시에 클래스 파일에 자동으로 생성되어 저장되며 같은 내용은 한번만 저장된다. 상수와 마찬가지로 constant pool에 저장된다.

빈 문자열(empty string)
: 길이가 0인 배열을 갖고 있는 문자열이 빈 문자열. 예시, String s ="";
char 타입은 하나의 문자가 있어야 한다. Char c = ' ';

---

--🌡 String클래스의 생성자와 메서드 ( p.334 ~ p.336 참고 )

String(String s)
: 주어진 문자열 s를 갖는 String인스턴스 생성

String(char[ ] value)
: 주어진 배열의 문자를 결합한 문자열 value를 갖는 String인스턴스 생성

String(StringBuffer buf)
: StringBuffer인스턴스가 갖고 있는 문자열과 같은 String인스턴스 생성

char charAt(int index)
: 지정된 위치(index)에 문자를 알림

int compareTo(String str)
: 문자열 str과 사전순서로 비교. 같으면 0, 이전 사전순은 음수, 이후 사전순은 양수

String concat(String str)
: 문자열 str을 뒤에 붙인다

boolean contains(CharSequence s)
: 지정된 문자열 s가 포함되었는지 검사

boolean startsWith(String prefix)
: 주어진 문자열 prefix로 시작하는지 검사

boolean endsWith(String suffix)
: 지정된 문자열 suffix로 끝나는지 검사

boolean equals(Object obj)
: Object 클래스 내 설명 참고

boolean equalsIgnoreCase(String str)
: 문자열과 String인스턴스의 문자열을 대소문자 구분없이 비교

int indexOf(int ch)
: 주어진 문자 ch가 문자열에 존재할 경우 위치(index)를 알려준다. 못 찾으면 음수를 반환

int indexOf(int ch, int pos)
: 주어진 문자 ch가 문자열에 존재하는지 지정된 위치 pos부터 확인하여 위치(index)를 알려준다. 못 찾으면 음수를 반환

int indexOf(String str)
: 주어진 문자열 str이 문자열에 존재할 경우 그 위치(index)를 알려준다. 못 찾으면 음수를 반환

String intern( )
: 문자열을 상수풀(constant pool)에 등록, 이미 등록된 경우 주소값을 반환

int lastIndexOf(int ch)
: 지정된 문자 ch 또는 문자코드를 문자열 오른쪽 끝에서 찾아서 위치(index)를 알려준다. 못 찾으면 음수를 반환

int lastIndexOf(String str)
: 지정된 문자열 str을 인스턴스 문자열 끝에서 부터 찾아서 위치(index)를 알려준다. 못 찾으면 음수를 반환

String replace(char old, char nw)
: 문자열 중 문자 old를 새로운 문자 nw로 바꾼 문자열을 반환

String replace(CharSequence old, CharSequence nw)
: 문자열 중 문자열 old를 새로운 문자열 nw로 바꾼 문자열을 반환

String replaceAll(String regex, String replacement)
: 문자열 중에서 지정된 문자열 regex와 일치하는 것을 새로운 문자열 replacement로 모두 변경

String replaceFirst(String regex, String replacement)
: 문자열 중에서 지정된 문자열 regex와 일치하는 것 중 첫번째만을 새로운 문자열 replacement로 변경

String[ ] split(String regex)
: 문자열을 지정된 분리자 regex로 나누어 문자열 배열에 담아 반환

String[ ] split(String regex, int limit)
: 문자열을 지정된 분리자 regex로 나누어 문자열 배열에 담아 반환, 단 문자열 전체 중 지정된 수 limit만큼 자른다.

String substring(int begin)
String substring(int begin, int end)
: 주어진 시작위치 begin부터 끝 위치 end범위에 포함된 문자열을 얻는다. 이때 끝 위치의 문자는 포함되지 않는다. ( begin <= x < end )

String toLowerCase( )
: String인스턴스에 저장된 모든 문자열을 소문자로 변환하여 반환

String toString( )
: Object 클래스 내 설명 참고

String toUpperCase( )
: String인스턴스에 저장된 모든 문자열을 대문자로 변환하여 반환

String trim( )
: 문자열의 왼쪽 끝과 오른쪽 끝에 공백을 없앤 결과를 반환

static String valueOf(boolean b)
static String valueOf(char c)
static String valueOf(int i)
static String valueOf(long l)
static String valueOf(float f)
static String valueOf(double d)
static String valueOf(Object o)
: 지정된 값을 문자열로 변환하여 반환, 참조변수의 경우 toString( )을 호출한 결과를 반환

--🌡 추가 참고

CharSequence
: JDK1.4부터 추가된 인터페이스로 String, StringBuffer 등의 클래스가 구현

: JDK1.5부터 contains(CharSequence s), replace(CharSequence old, CharSequence nw)가 추가

java.util.Date dd = new java.util.Date( )
: 생성된 인스턴스는 현재 시간을 갖는다.

---

join( )과 StringJoiner

join( )
: split( )와 반대로 여러 문자열 사이에 구분자를 넣어서 결합한다. JDK1.8부터 추가

StringJoiner
: 문자열 결합. 아래와 같다.

public StringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix) 
: 구분자, 접두사(prefix), 접미사(suffix)를 통해 문자열을 결합

문자열과 기본형 간의 변환
: 문자열을 숫자로, 숫자를 문자열로 변환

방법 1
: 빈 문자열 ""을 더해 숫자를 문자열로 바꿀 수 있다.

방법 2
: String.valueOf( 숫자로 된 참조변수 )로 숫자를 문자열로 바꿀 수 있다. 참조변수가 가리키는 인스턴스의 toString( )을 호출해 String을 얻고 결합한다. 

--🌡 문자열 → 기본형

Boolean.parseBoolean(String s)
Byte.parseByte(String s)
Short.parseShort(String s)
Integer.parseInt(String s)
Long.parseLong(String s)
Float.parseFloat(String s)
Double.parseDouble(String s)
: 문자열을 기본형으로 변환. valueOf로도 기본형 → 문자열로, 문자열 → 기본형으로 바꿀 수 있다. valueOf는 Interger 타입이지만 오토박싱(auto-boxing)으로 자동으로 int로 변환된다.

만약, byte, short를 문자열로 변환 시 String valueOf(int i)로 int를 사용하면 된다.

JDK1.7부터 "+"가 포함된 문자열이 parseInt( )로 변환가능

static int parseInt(String a, int radix)
: 16진수 값으로 표현된 문자열도 반환. a의 경우 정수값 10이 반환된다.

StringBuffer클래스와 생성자
: 문자열 변경과 더불어 문자열 길이 조절 가능한 클래스. Buffer의 크기는 기본적으로 16개의 문자를 저장할 수 있는 크기이며 이를 변경할 수 있다.

---

--🌡 StringBuffer의 생성자와 메서드

StringBuffer( )
: 16문자를 담을 수 있는 Buffer를 가진 StringBuffer 인스턴스를 생성

StringBuffer( int length )
: 지정된 개수의 문자를 담을 수 있는 버퍼를 가진 StringBuffer 인스턴스를 생성

StringBuffer( String str )
: 지정된 문자열 값 str를 갖는 StringBuffer 인스턴스를 생성

StringBuffer append(boolean b)
StringBuffer append(char c)
StringBuffer append(char[ ] str)
StringBuffer append(double d)
StringBuffer append(float f)
StringBuffer append(int i)
StringBuffer append(long l)
StringBuffer append(Object obj)
StringBuffer append(String str)
: 매개변수를 문자열로 변환한 뒤 StringBuffer인스턴스가 저장하고 있는 문자열의 뒤에 추가

int capacity( )
: StringBuffer인스턴스의 Buffer의 크기를 알려준다. length( )는 Buffer에 담긴 문자열의 길이를 알려준다.

char charAt(int index)
: 지정된 위치에 있는 문자를 반환

StringBuffer delete(int start, int end)
: 시작위치부터 끝 위치 사이에 문자를 제거, 단 끝 위치의 문자는 제외

StringBuffer deleteCharAt(int index)
: 지정된 위치의 문자를 제거

StringBuffer insert(int pos, boolean b)
StringBuffer insert(int pos, char c)
StringBuffer insert(int pos, char[ ] str)
StringBuffer insert(int pos, double d)
StringBuffer insert(int pos, float f)
StringBuffer insert(int pos, int i)
StringBuffer insert(int pos, Object obj)
StringBuffer insert(int pos, String str)
: 두 번째 매개변수로 문자열을 변환하여 지정한 위치 pos에 추가. 0부터 시작

int length( )
: StringBuffer인스턴스에 저장되어 있는 문자열의 길이를 반환

StringBuffer replace(int start, int end, String str)
: 지정된 범위( start ~ end )의 문자들을 주어진 문자열로 바꾼다. end 위치는 포함되지 않는다 ( start <= x < end )

StringBuffer reverse( )
: StringBuffer인스턴스에 저장되어 있는 문자열의 순서를 거꾸로 나열

void setCharAt(int index, char ch)
: 지정된 위치의 문자를 주어진 문자 ch로 바꾼다.

String toString( )
: StringBuffer인스턴스의 문자열을 String으로 반환

String substring(int start)
String substring(int start, int end)
: 지정된 범위 내 문자열을 String으로 뽑아서 반환. 시작위치 start만을 지정하면 시작위치부터 끝까지 뽑아서 반환.

---

StringBuilder
: StringBuffer에서 쓰레드의 동기화만 뺀 것. StringBuffer는 멀티쓰레드에서 안전(thread safe)하도록 동기화되어 있다. 이 동기화가 StringBuffer의 성능을 떨어뜨린다.

--🌡 참고, 대부분 예제는 싱글 쓰레드로 작성되어 있다.

Math클래스
: 수학계산에 유용한 메서드로 구성

반올림
: 일반적인 계산으로 정수 값에 10의 n제곱으로 곱한 뒤 10의 n제곱만큼의 정수를 .0 붙여 실수로 나누면 원하는 반올림 자리에 수를 얻는다. 

--🌡 Math 메서드

static double abs(double a)
static double abs(float f)
static int abs(int f)
static long abs(long f)
: 주어진 값의 절대값을 반환

static double ceil(double a)
: 주어진 값을 올림하여 반환

static double floor(double a)
: 주어진 값을 버림하여 반환. 음수를 버림하면 더 큰 음수 값으로 반환

static double max(double a, double b)
static float max(float a, float b)
static int max(int a, int b)
static long max(long a, long b)
: 주어진 두 값을 비교하여 큰 쪽을 반환

static double min(double a, double b)
static float min(float a, float b)
static int min(int a, int b)
static long min(long a, long b)
: 주어진 두 값을 비교하여 작은 쪽을 반환

static double random()
: 0.0 ~ 1.0 범위의 임의의 double값을 반환. ( 1.0은 범위에 포함되지 않는다. )

static double rint(double a)
: 주어진 double값을 가장 가까운 정수값을 double형으로 반환. 단, 두 정수의 정가운데 있는 값( 1.5, 2.5, 3.5 ... )는 짝수를 반환

static long round(double a)
static long round(float a)
: 소수점 첫째자리에서 반올림한 정수값 long을 반환. 두 정수의 정가운데 있는 값( 1.5, 2.5 ... )는 항상 큰 정수를 반환

---

래퍼(wrapper) 클래스
: Java는 기본형 타입 8개 ( bit, byte, short, char, int, long, float, double )은 객체로 다루지 않아 완전한 객체지향 언어가 아니라는 이야기도 한다.
이 기본형 타입을 객체로 다루어야 할 때 쓰는 클래스가 래퍼(wrapper) 클래스이다.

--🌡 래퍼(wrapper) 클래스 생성자

-- boolean
Boolean(boolean value)
Boolean(String s)

-- char
Character(char value)

-- byte
Byte(byte value)
Byte(String s)

-- short
Short(short value)
Short(String s)

-- int
Integer(int value)
Integer(String s)

-- long
Long(long value)
Long(String s)

-- float
Float(double value)
Float(float value)
Float(String s)

-- double
Double(double value)
Double(String s)

래퍼클래스별 공통
: static 상수인 MAX_VALUE, MIN_VALUE, SIZE, BYTES, TYPE를 갖고 있다. BYTES는 JDK1.8부터 추가

진법(redix)에 따른 변환

static int parseInt(String s, int radix)
static Integer valueOf(String s, int radix)

radix에 2, 8, 16를 대입해 각 2, 8, 16진법에 따른 변환이 가능하다. 

JDK1.5 이전에는 기본형과 참조형 간 사칙연산조차 불가.

오토박싱(autoboxing)과 언박싱(unboxing)

intValue( )
: Compiler가 Integer객체를 int 타입으로 값을 변환해주는 intValue( )를 추가해줌으로써 int와 Integer가 연산이 가능하다.

Vector클래스나 ArrayList클래스에 기본형값을 래퍼 클래스의 객체로 자동 변환하는 걸 오토박싱(autoboxing), 반대로 변환하는 걸 언박싱(unboxing)이라 한다.

---

날짜와 시간
Date
: JDK1.0부터 제공된 날짜와 시간을 다루는 클래스. 

Calendar
: JDK1.1부터 제공된 달력 클래스

java.time.클래스
: JDK1.8부터 제공된 개선된 날짜, 시간 클래스

--🌡 java.util 패키지에 속한 클래스로, java.sql패키지의 Date클래스와 다르다.

Calendar 클래스
: Calendar는 추상클래스이기 때문에 직접 객체를 생성할 수 없다.

gitInstance( )
: 태국인 경우 BuddhisCalendar의 인스턴스 반환. 그 외에는 GregorianCalendar의 인스턴스 반환

Calendar 메서드

Calendar.YEAR
: 올 해 년도

Calendar.MONTH
: 이 번달, 0 ~11 이므로 0이 1월이다.

Calendar.WEEK_OF_YEAR
: 올 해의 몇째 주

Calendar.WEEK_OF_MONTH
: 이 번달의 몇째 주

Calendar.DATE
: 이 번달의 몇 일

Calendar.DAY_OF_MONTH
: 이 번달의 몇 일. Calendar.DATE와 같다.

Calendar.DAY_OF_YEAR
: 올 해의 몇 일

Calendar.DAY_OF_WEEK
: 요일. 1~7 중 1이 일요일

Calendar.DAY_OF_WEEK_IN_MONTH
: 이 번달의 몇째 요일

Calendar.AM_PM
: 오전은 0, 오후는 1

Calendar.HOUR
: 시간 0 ~ 11

Calendar.HOUR_OF_DAY
: 시간 0 ~ 23

Calendar.MINUTE
: 분

Calendar.SECOND
: 초

Calendar.MILLISECOND
: 1000분의 1초, 0 ~ 999

Calendar.ZONE_OFFSET
: MILLIISECOND 단위이며 만약 시로 표현하고자 할 경우 60 * 60 * 1000을 곱하여 준다. -12 ~ +12로 표현이 된다.

날짜 인스턴스.get( )
: 필드 읽기

날짜 인스턴스.set( )
: 필드 변경

날짜 인스턴스.clear( )
: 필드 초기화

날짜 인스턴스.getActualMaximum(Calendar.DATE)
: 이 달의 마지막 날

날짜 인스턴스.getTimeInMillis( )
: 날짜 인스턴스의 시간을 Milli Second 단위로 

날짜 인스턴스.add(Calendar 생성자, 숫자)
: 날짜 인스턴스의 생성자에 따라 숫자만큼 증가, 감소시킨다.

날짜 인스턴스.roll(Calendar 생성자, 숫자)
: 날짜 인스턴스의 생성자에 따라 숫자만큼 증가, 감소시키나 그 외 다른 필드에는 값이 영향이 없다. 

--🌡 Date와 Calendar간의 변화

-- Calendar를 Date로 변환

Calendar cal = Calendar.getInstance( );

Date d = new Date(cal.getTimeInMillis()); // Date(long date)

-- Date를 Calendar로 변환

Date d = new Date( );

Calendar cal = Calendar.getInstance( );

---

형식화 클래스
: java.text 패키지에 포함된 숫자, 날짜, 텍스트 데이터를 일정한 형식에 맞게 표현할 수 있다.

DecimalFormat
: 십진법 형식 지정으로, 숫자 데이터를 정수, 부동소수점, 금액 등 다양한 형식으로 표현

DecimalFormat인스턴스를 생성한 하 format 메서드를 호출하여 원하는 형식으로 변환한 문자열을 얻는다.

0
: 10진수. 값이 없을 땐 0

#
: 10진수

.
: 소수점

-
: 음수부호

,
: 단위 구분자. 예, 100,000,000

E
: 지수기호

;
: 패턴구분자

%
: 퍼센트( % )

\u2030
: 퍼밀 ( % x 10 )

\u00A4
: 통화

`
: escape문자

--🌡 Integer.parseInt( )와 Integer.parse( )
Integer.parseInt( )는 콤마( , )가 포함된 문자열을 숫자로 변환불가 
Integer.parse( )는 기호와 문자가 포함된 문자열을 숫자로 변환가능. substring( )는 기호를 빼내어야 하는 수고가 있다.

SimpleDateFormat
: 추상 클래스인 DateFormat은 SimpleDateFormat 클래스의 조상 클래스. Date와 Calendar보다 간단히 날짜를 구현할 수 있는 클래스

컬렉션 프레임웍 ( Collection Framework )
: 다수의 데이터( data group, collection )를 다루기 위한 단일화된 구조(architecture)

이 때 다룬다는 것은 "저장, 삭제, 검색, 정렬"을 다룬다는 뜻이다.

--🌡 
JDK1.2 이전에는 Vector, Hashtable, Properties와 같은 Collection 클래스를 각각 방식으로 구현. 
JDK1.2 이후에는 Collection Framework으로 모든 클래스를 다룰 수 있게 바뀌었다.

라이브러리(library)와 프레임웍(framework)

라이브러리(library)
: 공통으로 사용될 만한 유용한 기능을 모듈화(module)하여 제공

모듈(module)
: 본체에 대한 독립된 하위 단위

프레임웍(framework)
: 라이브러리(library)와 정형화된 프로그래밍(Programming) 방식

Collection framework의 핵심 Interface
: List, Set, Map이 있다. Collection은 List와 Set의 공통된 부분을 모은 Interface.

List
: 순서가 있는 데이터의 집합. 데이터의 중복을 허용. ArrayList, LinkedList, Stack, Vector

Set
: 순서가 없는 데이터의 집합. 데이터의 중복을 허용 안 함. HashSet, TreeSet

Map
: 키(Key)와 값(Value)의 쌍(Pair)로 이뤄진 데이터의 집합. 키(Key)는 중복 허용 안 함, 값(Value)는 중복 허용.
HashMap, TreeMap, Hashtable, Properties

--🌡 열쇠(key)는 어떤 값(value)을 찾는 데 열쇠(key)가 된다는 의미에서 유래.

---

Collection 인터페이스
: List와 Set의 조상 Interface.

--🌡 Collection Interface의 Method( ) ( List와 Set 인터페이스의 공용 )

Collection은 인터페이스(Interface), Collections는 클래스(Class)이다.

boolean add(Object o)
boolean addAll(Collection c)
: 지정된 객체(o) 또는 Collection(c)의 객체들을 Collection에 추가한다.

void clear( )
: Collection의 모든 객체를 삭제

boolean contains(Object o)
boolean containsAll(Collection c)
: 지정된 객체(o) 또는 Collection(c)의 객체들을 Collection에 포함됬는지 확인

boolean equals(Object o)
: 동일한 Collection인지 비교

int hashCode( )
: Collection의 hash code를 반환

boolean isEmpty( )
: Collection이 비었는지 확인

iterator iterator( )
: Collection의 iterator를 얻어서 반환. iterator는 반복자라는 뜻이며 Collection에 저장된 요소를 접근하는데 사용되는 Interface

boolean remove(Object o)
: 지정된 객체를 삭제

boolean removeAll(Collection c)
: 지정된 Collection에 포함된 객체들을 삭제

boolean retainAll(Collection c)
: 지정된 Collection에 포함된 객체만을 남기고 다른 객체들은 삭제, 이 작업으로 인해 Collection에 변화가 있으면 true, 아니면 false를 반환

int size( )
: Collection에 저장된 객체의 개수 반환

Object[ ] toArray( )
: Collection에 저장된 객체를 객체배열 Object[ ] 로 반환

Object[ ] toArray( Object[ ] a )
: 지정된 배열에 Collection의 객체를 저장해 반환

JDK1.8 부터는 parallelStream, removeIf, stream, forEach는 람다(Lambda)와 스트림(Stream)에서 설명

--🌡 Java API 문서에 E, K, V 등의 기호는 지네릭스에 의한 표기로, Object 타입을 가진다.

List 인터페이스
: List -- ArrayList / LinkedList / Vector -- Stack 

void add(int index, Object element)
boolean addAll(int index, Collection c)
: 지정된 위치(index)에 객체(element) 또는 컬렉션에 포함된 객체들 추가

Object get(int index)
: 지정된 위치(index)에 있는 객체를 반환

int indexOf(Object o)
: 지정된 객체의 위치(index)를 반환. List의 첫 번째 요소부터 순방향으로 찾기

int lastIndexOf(Object o)
: 지정된 객체의 위치(index)를 반환. List의 마지막 요소부터 역방향으로 찾기

ListIterator listIterator( )
ListIterator listIterator(int index)
: List의 객체에 접근할 수 있는 ListIterator를 반환

Object remove(int index)
: 지정된 위치(index)에 있는 객체를 삭제 후 삭제된 객체를 반환

Object set(int index, Object element)
: 지정된 위치(index)에 객체(element)를 저장

void sort(Comparator c)
: 지정된 비교자(comparator)로 List를 정렬

List subList(int fromIndex, int toIndex)
: 지정된 범위( fromIndex부터 toIndex까지 )에 있는 객체를 반환

---

Set 인터페이스
: Set -- HashSet / SortedSet -- TreeSet

위의 Collection Interface의 Method( )와 같다.

---

Map 인터페이스
: Map -- Hashtable / HashMap -- LinkedHashMap / SortedMap -- TreeMap

void clear( )
: Map의 모든 객체를 삭제

boolean containKey(Object key)
: 지정된 key객체와 일치하는 Map의 key 객체가 있는지 확인

boolean containsValue(Object value)
: 지정된 value객체와 일치하는 Map의 value 객체가 있는지 확인

Set entrySet( )
: Map에 저장되어 있는 key-value쌍을 Map.Entry타입의 객체로 저장한 Set을 반환

boolean equals(Object o)
: 동일한 Map인지 비교

Object get(Object key)
: 지정한 key객체에 대응하는 value객체를 찾아서 반환

int hashCode( )
: 해시코드 반환

boolean isEmpty( )
: Map이 비어있는지 확인

Set KeySet( )
: Map에 저장된 모든 key객체를 반환

Object put(Object key, Object value)
: Map에 value객체를 key객체에 연결(mapping)하여 저장

void putAll(Map t)
: 지정된 Map의 모든 key-value쌍을 추가

Object remove(Object key)
: 지정한 key객체와 일치하는 key-value객체를 삭제

int size( )
: Map에 저장된 key-value쌍의 개수를 반환

Collection values( )
: Map에 저장된 모든 value객체를 반환

--🌡 Map Interface는 값(value)은 중복허용이 가능하므로 Collection타입으로 반환, 키(key)는 중복허용이 되지 않아 Set타입으로 반환

---

ArrayList Interface
: ArrayList interface는 기존 Vector Interface를 개선한 Interface이다.

위의 Collections과 List Interface에서의 메서드와 중복은 제외

ArrayList( )
: 크기가 0인 ArrayList를 생성

ArrayList( Collection c )
: 주어진 컬렉션이 저장된 ArrayList 생성

ArrayList(int intialCapacity)
: 지정된 초기용량을 갖는 ArrayList 생성

boolean add(Object o)
: ArrayList의 마지막에 객체를 추가, 성공 시 true

void clear( )
: ArrayList를 완전히 비운다.

Object clone( )
: ArrayList를 복제

void ensureCapacity(int minCapacity)
: ArrayList의 용량이 최소한 minCapacity가 되도록 한다.

void trimToSize( )
: 빈 공간을 없애 용량을 크기에 맞게 줄인다. 

ArrayList의 추가와 삭제
: 삭제할 객체 마지막 객체일 경우 null로 변경, 그 외에는 삭제할 객체의 바로 아래에 데이터를 한 칸 위로 복사해 덮어쓴 뒤 마지막 객체를 null로 변경 후
데이터의 개수(size)를 -1 만큼 감소한다.

--🌡 데이터의 개수가 많을 수록 작업시간이 오래 걸린다.

---

LinkedList Interface

: 배열은 자료구조로 구조가 간단 접근시간(access time)이 가장 빠르다 또한 크기를 변경할 수 없고 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
이를 보완한 것이 linked list이다.

Linked list의 각 요소(Node)마다 연결된 다음 요소에 대한 참조(주소 값)와 데이터로 구성

class Node {
   Node next;  // 다음 요소의 주소를 저장
   Object obj;  // 데이터를 저장
}

LinkedList의 추가와 삭제

삭제
: 복사하는 과정없이 삭제하고자 하는 요소의 이전 요소와 다음 요소를 서로 참조하도록 변경하면 된다.

추가
: 새로운 요소(node)를 생성하고 이전 요소와 새로운 요소, 그리고 다음 요소와 새로운 요소를 새로 참조하도록 변경하면 된다.

---

ArrayList와 LinkedList의 비교

위치(Index)가 n인 데이터의 주소
: 배열의 주소 + n * 데이터 타입의 크기

ArrayList
: 읽기가 빠르다, 추가와 삭제가 느리다. 순차적인 추가삭제는 빠르고 비효율적인 메모리사용
따라서, 데이터의 개수가 변하지 않는 경우 주로 사용

LinkedList
: 읽기가 느리다, 추가와 삭제가 빠르다. 데이터가 많을수록 접근성이 떨어진다.
따라서, 데이터의 개수가 자주 변하는 경우 주로 사용

---

스택(Stack)과 큐(Queue)

스택(Stack)
: LIFO(Last In, First Out) 구조로, 마지막에 저장한 데이터부터 먼저 작업
저장을 push, 추출을 pop이라 부른다. ArrayList가 적합

예시, 수식계산, 수식괄호검사, 뒤로/앞으로

큐(Queue)
: FIFO(First In, First Out) 구조, 처음에 저장한 데이터부터 먼저 작업
저장을 offer, 추출을 poll이라 부른다. LinkedList가 적합

예시, 최근 사용문서, 인쇄작업 대기목록, 버퍼(buffer)

--🌡 Stack method

Stack Class 생성자 생성
: new Stack( )

저장
Object push(Object item)
: Stack에 객체(item)를 저장

객체 추출
Object pop( )
: Stack의 맨 위에 저장된 객체를 꺼낸다. 비었을 경우 EmptyStackException 발생

boolean empty( ) or boolean isEmpty( )
: Stack이 비었는지 확인

Object peek( )
: Stack의 맨 위에 저장된 객체를 반환. pop( )과 달리 stack에서 객체를 꺼내지 않음
비었을 경우 EmptyStackException 발생

int search(Object o)
: Stack에서 주어진 객체( o )를 찾아서 그 위치를 반환. 못 찾으면 -1을 반환.
배열과 달리 위치는 0이 아닌 1부터 시작하며 맨 위의 요소가 1이다.

--🌡 Queue method

Queue Interface 구현
: new LinkedList( )
Queue는 인터페이스로만 정의해 놓았다.

저장
boolean offer( Object o )
: Queue에 객체를 저장. 성공하면 true, 실패 시 false 반환

객체 추출
Object poll( )
: Queue에서 객체를 꺼내 반환. 비어있으면 null

삭제
Object remove( )
: Queue에서 객체를 꺼내 반환. 비었을 경우 NoSuchElementException 발생

boolean add( Object o )
: 지정된 객체를 Queue에 추가, 성공하면 true를 반환. 
저장공간이 부족할 경우 illegalStateException 발생

Object element( )
: 삭제없이 요소를 읽어온다. peek와 달리 Queue가 비었을 경우 NoSuchElementException 발생

Object peek( )
: 삭제없이 요소를 읽어온다. Queue가 비었을 경우 null 반환

--🌡 Java API에서 Queue Interface

: All Known Implementing Classes에 정의된 메서드를 사용

---

Iterator, ListIterator, Enumeration
: Collection에 저장된 요소를 접근하는데 사용하는 Interface용


ListIterator
: Iterator에 양방향 조회기능 추가( List를 구현한 경우만 사용 )

--🌡 ListIterator

Iterator와는 달리 next( )와 previous( )의 method가 있기 때문에 양방향으로 조회할 수 있다.

--

Iterator
: Collection에 저장된 요소를 접근하는데 사용되는 Interface. Collection Interface의 자손인 List, Set Interface에서도 사용할 수 있다.

단, 조회는 1회용이라 다시 조회하려면 Iterator를 다시 얻어와야 한다.

--🌡 Iterator의 method

boolean hasNext( )
: 읽어 올 요소(Node)가 남아있는지 확인, 있으면 true, 없으면 false

Object next( )
: 다음 요소(Node)를 읽어 온다. next( )보다는 hasNext( )로 먼저 확인하는 것이 안전하다.

--

Enumeration ( 열거형 ) 
: Iterator의 구버전

--🌡 Enumeration의 method

boolean hasMoreElements( )
: Iterator의 hashNext( )와 같다.

Object nextElement( )
: Iterator의 next( )와 같다.


Map과 Iterator
: Map에는 Iterator( )가 없기에 keySet( ), entrySet( ), values( )를 호출하여 Iterator( )에 접근한다.

Set Interface
: keySet( ), entrySet( )

Collection Interface
: value( )

--🌡 Map Interface를 구현한 Collection 클래스
: Iterator it = map.entrySet( ).iterator( )

---

Arrays의 method
: 복사, 채우기, 정렬, 검색, 비교, 출력, 변환

배열의 복사
: copyOf( ), copyOfRange( )

copyOf ( )
: 배열 전체를 복사

copyOfRange( )
: 배열의 일부를 복사, 지정된 범위의 끝은 포함되지 않는다.

배열 채우기
: fill( ), setAll( )

fill( )
: 배열의 모든 요소를 채운다.

setAll( )
: 배열을 채울 때 함수형 인터페이스와 람다식으로 채운다.

배열의 정렬과 검색
: sort( ), binarySearch( )

sor( )
: 배열을 정렬

binarySearch( )
: 배열에 저장된 요소를 검색. 단 정렬이 선행되어야 한다.

--🌡 순차검색(linear search)와 이진검색(binary search)

순차 검색( linear search )
: 배열의 첫 요소부터 순서대로 하나씩 검색

이진 검색( binary search )
: 배열의 검색할 범위를 절반씩 줄여가며 반복하여 검색. TreeSet 클래스가 있다. 


parallel( )
: 여러 쓰레드가 작업을 나누어 처리

spliterator( )
: 여러 쓰레드가 처리할 수 있게 여러 작업으로 나눈다.

stream( )
: Collection을 Stream으로 바꾼다.

--

문자열 배열의 비교와 출력
: equals( ), deepEquals( ), toString( ), deepToString( )

equals( )
: 1차원 배열에서의 비교

deepEquals( )
: 다차원 배열에서의 비교

toString( )
: 1차원 배열에서의 비교

deepToString( )
: 다차원 배열에서의 비교

배열의 변환
: asList( Object ... a )

asList( Object... a )
: 배열을 List에 담아 반환. 매개변수의 타입이 가변인수이기에 배열을 생성하지 않고 요소들을 나열할 수 있다.

단, 내용은 변경가능하나 배열의 크기 변경, 추가, 삭제은 불가하다. 그러나 new ArrayList( Arrays.asList( 요소들 ) )로 생성하여 변경이 가능하다.

---

Comparator ( 비교기 )와 Comparable ( 비교 가능한 )
: Collection을 정렬하는데 필요한 interface

Compare : 뜻은 비교

Comparator
: 두 Object를 비교. 기본 정렬 외에 다른 기준으로 정렬코자 할 때 사용

Comparable
: 객체 자신(this)와 Object를 비교. 기본 정렬기준으로 구현

campareTo( )
: 같으면 0, 비교하는 값보다 작으면 음수(내림차순), 큰 경우 양수(오름차순)

--🌡 오름차순은 유니코드의 순서로 작은 값부터 큰 값으로 정렬. 공백, 숫자, 대문자, 소문자의 순이다.

static void sort( Object[ ] a, Comparator c )
: 정렬을 하려면 정렬할 대상, 정렬 기준이 필요하다.

--🌡 버블 정렬 공식

---

HashSet
: Set인터페이스를 구현한 Collection. 

중복된 값은 저장되지 않으나 1이라는 값으로 Interger인스턴스, String인스턴스와 같이 타입이 다르면 서로 다른 객체이므로 저장이 된다.

LinkedHashSet
: HashSet과는 달리 저장순서를 유지하고자 할 경우에 사용

HashSet( )
: HashSet 객체 생성

HashSet(Collection c)
: 주어진 Collection을 포함한 HashSet객체 생성

HashSet(int initialCapacity)
: 주어진 값을 초기용량으로 하는 HashSet객체 생성

HashSet(int initialCapacity, float loadFactor)
: 초기용량과 load factor를 지정하는 생성자

--🌡 load factor는 저장공간이 가득 차기 전에 미리 용량을 확보하기 위함, 기본값은 75%인 0.75이다.

boolean add(Object o)
: 새로운 객체를 저장, 성공 시 true, 실패 시 false

boolean addAll(Collection c)
: 주어진 컬렉션에 저장된 모든 객체들을 추가

void clear( )
: 저장된 모든 객체 삭제

Object clone( )
: HashSet을 복제해 반환. 얕은 복사.

boolean contains(Object o)
: 지정된 객체를 포함하는 지 확인

boolean containsAll(Collection c)
: 주어진 컬렉션에 저장된 모든 객체들을 포함하는 지 확인

boolean isEmpty( )
: HashSet이 비었는지 확인

Iterator iterator( )
: Collection에 저장된 요소를 접근

boolean remove( Object o )
: 지정된 객체를 HashSet에서 삭제. 성공 시 true, 실패 시 false

boolean removeAll( Collection c )
: 주어진 컬렉션에 저장된 모든 객체와 동일한 객체들을 삭제

boolean retainAll( Collection c )
: 주어진 컬렉션에 저장된 객체와 동일한 것만 남기고 삭제 ( 교집합 )

int Size( )
: 저장된 객체의 개수를 반환

Object[ ] toArray( )
: 저장된 객체들을 객체배열의 형태로 반환

Object[ ] toArray( Object[ ] a )
: 저장된 객체들을 주어진 객체배열( a )에 담기

--🌡 JDK1.8 부터 Stream과 관련된 메서드들도 추가되었다.

---

TreeSet
: 이진 탐색 트리(binary search tree)의 자료구조의 형태로 데이터를 저장하는 구조. 이진 탐색 트리를 향상시킨 레드-블랙(Red-Black tree)으로 구현.
정렬, 검색, 범위검색(range search)에 높은 성능을 보이는 자료 구조

각 node별로 최대 2개의 node를 연결할 수 있으며 루트(root) node에서 확장해 나아간다.

class TreeNode {
    TreeNode left;   // 왼쪽 자식 node
    Object element; // 객체를 저장하기 위한 참조변수
    TreeNode right; // 오른쪽 자식 node
}

이진 탐색 트리(binary search tree)
: 부모노드의 왼쪽엔 부모노드의 값보다 작은 값의 자식노드를, 오른쪽엔 높은 값의 자식노드를 저장하는 이진 트리(binary tree)이다.

범위검색과 정렬에 유리하며 추가와 삭제에는 시간이 걸리며 중복된 값을 저장하지 못 한다.

---

--🍫 TreeSet의 method

/생성 

TreeSet( )
: 기본 생성자

TreeSet( Collection c )
: 주어진 Collection을 저장하는 TreeSet 생성

TreeSet ( Comparator comp )
: 주어진 정렬조건으로 정렬하는 TreeSet 생성

TreeSet ( SortedSet s )
: 주어진 Collection( SortedSet 구현 ) s를 저장하는 TreeSet 생성

boolean add ( Object o )
boolean addAll ( Collection c )
: 지정된 객체 o 또는 Collection c의 객체들을 Collection에 추가

/삭제

boolean remove( Object o )
: 지정된 객체 삭제

void clear( )
: 저장된 모든 객체 삭제

Object clone( )
: TreeSet을 복제해 반환

boolean retainAll( Collection c )
: 주어진 Collection과 공통된 요소(node)만 남기고 삭제. 교집합

/정렬

boolean isEmpty( )
: TreeSet이 비었는지 확인

boolean contains( Object o )
boolean containsAll( Collection c )
: 지정된 객체 o 또는 Collection의 객체들이 모두 포함됬는지 확인

Iterator iterator( )
: TreeSet의 Iterator를 반환

Comparator compatator( )
: TreeSet의 정렬기준(Compatator)을 반환

NavigableSet descendingSet( )
: TreeSet에 저장된 요소들을 역순으로 정렬해 반환

/검색

Object first( )
: 정렬된 순서에서 첫 번째 객체를 반환
 
Object last( )
: 정렬된 순서에서 마지막 객체 반환

Object pollFirst( )
: TreeSet의 첫 번째 요소(제일 작은 값의 객체)를 반환

Object pollLast( )
: TreeSet의 마지막 번째 요소(제일 큰 값의 객체)를 반환

Object higher( Object o )
: 지정된 객체보다 큰 값의 객체를 반환. 없으면 null

SortedSet tailSet( Object fromElement )
: 지정된 객체보다 큰 값의 객체들을 반환

Object ceiling ( Object o )
: 지정된 객체와 같은 객체를 반환. 없으면 제일 큰값에 가까운 값의 객체 반환. 이마저도 없으면 null

Object floor( Object o )
: 지정된 객체와 같은 객체를 반환. 없으면 제일 작은 값에 가까운 값의 객체 반환. 이마저도 없으면 null

SortedSet headSet( Object toElement)
: 지정된 객체보다 작은 값의 객체들을 반환

NavigableSet headSet( Ojbect toElement, boolean inclusive )
: 지정된 객체보다 작은 값의 객체들을 반환. inclusive가 true라면 같은 값도 반환

Object lower( Object o )
: 지정된 객체보다 제일 작은 값에 가까운 값의 객체를 반환. 없으면 null

int size( )
: 저장된 객체의 개수를 반환

Spliterator spliterator( )
: TreeSet의 spliterator를 반환

SortedSet subSet( Object fromElement, Object toElement )
: 범위 검색( fromElement와 toElement 사이 )의 결과를 반환. 끝 범위인 toElement는 포함되지 않는다.

NavigableSet subSet( Object fromElement, boolean fromInclusive, Object toElement, boolean toInclusive )
: 범위 검색( fromElement와 toElement 사이 )의 결과를 반환. fromInclusive가 true이면 시작값이 포함, toInclusive가 true이면 끝값이 포함

/배열

Object[ ] toArray( )
: 저장된 객체를 객체배열로 반환

Object[ ] toArray( Object[ ] o )
: 저장된 객체를 주어진 객체배열에 저장해 반환

---

🍫 HashMap과 Hashtable

: Hashtable과 HashMap의 관계는 Vector와 ArrayList와 같이 기능이 개선된 것의 차이이며 HashMap이 보다 더 개선되어 있다.

만약, 순서를 유지하고자 하려면 LinkedHashMap을 사용

--🍬 Hashtable은 동기화가 가능, HashMap은 동기화가 가능하지 않다.
: 13장 쓰레드 참고

--🍬 TreeSet과 TreeMap
: TreeSet은 TreeMap으로 만든 클래스이기에 같은 특징을 갖고 있다.

--🍬 HashMap 용도

: id 와 password 추가, 수정, 확인, 검증에도 사용 / 학점 계산  / 한정된 범위 내에 순차적인 값들의 빈도수 찾기

/ HashMap

: 키(key)와 값(value)을 묶어 하나의 데이터(entry)로 저장한다. 
해싱(hashing)이라는 방법으로 많은 양의 데이터를 검색하는데 탁월하다.

🍫 해싱(hashing) -- 책에 없는 내용

: 해시함수(hash function)에 의해 해시테이블(hash table)에 데이터(베열의 index)를 읽어오거나 저장하는 것

🍫 해시테이블(hash table) -- 책에 없는 내용

: 배열과 Linked list를 조합한 형태로 배열의 접근성과 Linked List에 데이터 변경의 유리함을 합쳐놓았다.

🍫 해시테이블(hash table)의 데이터 가져오는 과정 -- 책에 없는 내용

: 키(key)로 해시함수를 호출해 해시코드(hash code)를 얻는다. --
해시코드(해시함수의 반환 값)인 배열의 index에 대응하는 Linked List를 배열에서 찾는다. --
Linked List에서 키(key)와 일치하는 데이터(entry)를 찾는다.

--🍬 해시함수는 같은 키에 대해 항상 같은 해시코드를 반환해야 한다. 

🍫 HashMap의 키(key)와 값(value)

: HashMap은 키와 값을 모두 Object로 저장

/ 키(key)

: Collection 내의 키(key) 중 유일무이(unique)해야 한다.

/ 값(value)

: 키(key)와 달리 데이터 중복이 가능하다.

🍫 HashMap의 Method

/ 생성
HashMap( )
: HashMap 객체를 생성

HashMap( int initialCapacity )
: 지정된 값을 초기용량으로 하는 HashMap객체를 생성

HashMap( int initialCapacity, float loadFactor )
: 지정된 초기용량과 load factor의 HashMap객체를 생성

-🌡 load factor는 저장공간이 가득 차기 전에 미리 용량을 확보하기 위함, 기본값은 75%인 0.75이다.

Object clone( )
: 현재 HashMap을 복제해서 반환

Set entrySet( )
: HashMap에 저장된 키와 값을 엔트리(entry, 키와 값의 결합)의 행태로 Set에 저장해 반환

Set keySet( )
: HashMap에 저장된 모든 키가 저장된 Set을 반환

Collection values( )
: HashMap에 저장된 모든 값을 Collection의 형태로 반환

Object put( Object key, Object value )
: 지정된 키와 값을 HashMap에 저장

--🍬 Hashtable에서는 키(key)와 값(value)에 null을 허용하지 않는다. HashMap에서는 map.put(null, null)이나 map.put(null)이 가능하다.

void putAll( Map m )
: Map에 저장된 모든 요소를 HashMap에 저장

Object replace( Object key, Object value )
: 지정된 키의 값을 지정된 객체(value)로 대체

boolean replace( Object key, Object oldValue, Object newValue )
: 지정된 키와 객체( oldValue )가 모두 일치하는 경우에만 새로운 객체( newValue )로 대체


/ 삭제
void clear( )
: HashMap에 저장된 모든 객체 제거

Object remove( Object key )
: HashMap에서 지정된 키로 저장된 값(객체)을 제거


/ 검색

boolean isEmpty( )
: HashMap이 비었는지 확인

boolean containsKey( Object key )
: HashMap에 지정된 키(key)가 포함됬는지 확인. 포함이 되었으면 true

boolean containsValue( Object value )
: HashMap에 지정된 값(value)가 포함됬는지 확인. 포함이 되었으면 true

Object get( Object key )
: 지정된 키(key)의 값(객체)를 반환. 못 찾으면 null 반환

Object getOrDefault( Object key, Object defaultValue )
: 지정된 키(key)의 값(객체)를 반환. 키를 못 찾으면, 기본값(defaultValue)로 지정된 객체를 반환

int size( )
: HashMap에 저장된 요소의 개수를 반환

--🍬 Map Interface와 Entry Interface

Entry Interface
: Map의 내부 Interface

---

🍫 Collection의 method

단일 컬렉션
: checked

--🍬 JDK 1.5부터는 지네릭스(generics)로 사용하고 JDK1.5 이전은 checked를 사용해야 한다.

---

-- 12장부터는 메모를 줄이거나 메모를 하지 않는 중

🥞 지네릭스(generics)

: 컴파일 시의 타입 체크( compile-time type check )를 하여 필요한 곳에 형변환을 해준다. 컴파일 후에는 지네릭 타입을 제거한다.

🥞 제한된 지네릭 클래스

<타입 extends 클래스 & 인터페이스 >
: 제한된 클래스 내 자손들만 다루면서 인터페이스도 구현하고자 할 때 작성방법

🥞 지네릭 메서드

static <타입> void 메서드이름( ) { ... }
: 반환 타입 앞에 제네릭을 정의한 경우 지네릭 메서드라 한다. 지네릭 클래스의 <타입>과는 다르다.

🥞 #12-15 지네릭타입의 형변환

🥞 #12-16 지네릭 타입의 제거

🥞 #12.17 ~ 12.20 열거형(enum), 열거형의 정의와 사용, 열거형의 조상 Java.lang.Enum, 열거형 예제

enum 열거형이름 { 상수명1, 상수명2, 상수명3 }
: 상수이름에 순서대로 0, 1, 2의 값이 할당된다.

🥞 #12.21 ~ 12.22 열거형에 멤버 추가하기, 예제

열거형 생성자는 암묵적으로 private라서, 외부에서 객체생성이 불가하다.

🥞 #12.23~12.26 애너테이션(Annotation)이란?, 표준 애너테이션, @Override, @Deprecated

Annotation ( JDK에서 기본으로 제공하는 것은 meta annotation )
: java.lang.annotation 패키지에 포함되어 있다.
주석이지만 주로 Compiler와 소통에 있어 유효한 정보를 제공하여 준다.

🥞 #12.27~12.32 @FunctionalInterface, @SuppressWarnings, 메타 애너테이션, @Target, @Retention, @Documeted / @Inherited, @Repeatable

Compile 관련은 맨 위에 '🥤 Compile ( javac.exe )'의 내용 참고

@SuppressWarnins
: Compile 과정 중 만나는 경고 등을 줄이기 위한 Annotation. 
만약, 쌓이는 경고를 방치하면 겹겹히 쌓여 올바른 알림을 못 받을 수 있으니 @SuppressWarnins를 사용할 것

메타 애너테이션
: 애너테이션을 위한 애너테이션

@Retention
: @Retention(RetentionPolicy.SOURCE ( 또는 .CLASS, .RUNTIME) )으로 작성

🥞 #12.34~12.39 애너테이션 타입 정의하기, 애너테이션의 요소, 모든 애너테이션의 조상, 마커 애너테이션, 애너테이션 요소의 규칙, 애너테이션의 활용

애너테이션 만들기
: @interface 애너테이션이름 {
    타입 요소이름( ); // 애너테이션의 요소(element)를 선언한다.
    타입 요소이름( ) default 1; // null을 제외한 기본값을 줄 수 있다.
    ...
}

: 애너테이션에도 인터페이스처럼 상수를 정의할 수 있지만, default method는 정의할 수 없다.

모든 애너테이션의 조상
: Compiler가 `@interface 애너테이션이름 extends Annotation`와 같이 지정하지 않아도 Annotation interface에 equals(Object obj ), hashCode( ), toString( )을 사용할 수 있게 해준다.

마커 애너테이션
: 애너테이션의 요소가 하나도 정의되지 않은 애너테이션

🥤 Class<Ex12_8> cls = Ex12_8.class 에서
: 'Ex12_8.class'는 클래스 객체를 의미하는 리터럴이다, 클래스 파일은 클래스 로더(Class loader)에 의해 메모리에 올라갈 때, 클래스에 대한 정보가 담긴 객체를 생성하는데 이를 
클래스 객체라고 한다.

---

🥞 #13 쓰레드(thread), #13.1~13.6 프로세스(process)와 쓰레드(thread), 멀티쓰레딩의 장단점, 쓰레드의 실행 - start( ), start( )와 run( )

-- 프로세스와 쓰레드

Process
: 자원(resources)인 Memory, CPU를 일컫는다. 

쉽게 말해, 게임 속에 Command Center와 같다.

Thread
: 프로세스 내에 실제 작업을 수행하는 것. 모든 프로세스는 최소 하나의 쓰레드를 갖고 있다.

쉽게 말해, 게임 속에 SCV와 같다.


LWP ( Light-weight process )
: 경량 프로세스, 쓰레드를 가벼운 프로세스라고도 부른다.

--🥤 작업관리자 ( Ctrl + Alt + Delete ) -- 세부정보

PID 
: Process ID

이름, PID, 상태.. 열에서 Context Menu -- 열 선택 -- 스레드
: 스레드가 얼마인지 볼 수 있다.

-- 멀티 쓰레드의 장점

-- 🥤 CGI 와 JSP Servlet ( 1990년대 말 )

CGI ( Common Gateway Interface )
: 처음엔 단일 쓰레드를 사용했다.

JSP Servlet
: 멀티쓰레드(Multi Thread)로 당시 CGI의 단점을 보완했었다.

---

-- 멀티쓰레드의 단점

Synchronization
: 동기화

deadlock
: 교착상태. 두 쓰레드가 자원을 점유한 채, 서로 점유한 자원을 사용하려 기다리느라 진행이 멈춘 상태.

기아(굶어 죽는 현상)
: 쓰레드가 작업할 기회가 오지 않는 현상

-- 쓰레드 구현
: Thread클래스 상속 또는 Runnable Interface를 구현하여 쓰레드를 구현한다.

-- 쓰레드의 실행
: 한번 실행이 종료된 메서드는 다시 실행할 수 없기 때문에, 다시 생성 후 start( )로 실행하여야 한다.

-- start( )와 run( )

run( )
: Call stack에서 선언된 메서드를 호출하는 것일 뿐이다.

start( )
: Call stack에서 start( )가 호출되어 독립된 공간을 생성한 후 그 위에 run( )을 호출한 후 start( )는 소멸. 
두 Call stack인 main( )과 run( )을 OS의 Scheduler(스케줄러)가 정한 순서에 의해 번갈아 실행한다.

🥤 # 13.7~13.12 main 쓰레드, 싱글쓰레드와 멀티쓰레드, 예제1~2, 쓰레드의 I/O 블락킹(blocking), 예제 1~

사용자 쓰레드( user thread / non-daemon thread )

데몬 쓰레드( daemon thread )
: garbage collector ( 쓰레기 수집 ), 자동저장, 화면자동갱신 등에 쓰이는 보조 쓰레드

context switching
: 프로세스 또는 쓰레드 간의 작업 전환

I/O Blocking 
: 쓰레드가 사용자나 외부기기로부터 입출력( Input / Ouput ) 처리를 위해 기다리는 것

🥤 #13.14~13.19 쓰레드의 우선순위( priority ), 예제, 쓰레드 그룹(thread group), 쓰레드그룹의 메서드, 데몬쓰레드(daemon thread), 예제

🥤 #13.20~13.25 쓰레드의 상태, 쓰레드의 실행제어, sleep( ), 예제, interrupt( ), 예제

suspend( )
: 일시정지. ( 현재, deprecated된 상태 )

sleep( )
: 잠자기

wait( )
: 대기

join( )
: 다른 쓰레드를 기다리기

time-out
: 시간종료

resume( )
: 재개, suspend( )와 반대

notify( )
: wait( )와 반대  

interrupt( )
: 방해, 깨우기, sleep( ), join( )과 반대.

--🥤 쓰레드 프로그래밍이 어려운 이유

동기화(synchronization), 스케줄링(scheduling) 때문

-- 🥤 sleep( ), yield( )

: static method이기 때문에 자기 자신의 method에만 사용할 수 있다.

-- 🥤 interrupted( )와 isInterrupted( )

isInterrupted( )는 상태만을 반환, interrupted( )는 상태반환 후 추후 interrupt( )를 다시 호출하기 위해 false로 초기화.

# 13.26 suspend( ), resume( ), stop( ), 예제

--🥤 교착상태(deadlock)

: suspend( ), stop( )은 교착상태를 일으키기 쉬워 현재 deprecated가 되어있다. 

# 13.28~13.33 join( )과 yield( ), 예제, 쓰레드의 동기화(synchronization), synchronized를 이용한 동기화, 예제1, 예제2

임계영역(critical section)
: 쓰레드끼리 공유 데이터를 사용하는 영역

잠금(lock)
: 임계영역에서 공유데이터가 가지고 잇는 잠금(lock)을 통해 단 하나의 쓰레드만이 작업을 수행

-- 🥤 JDK1.5 부터는 java.util.concurrent에 locks, atomic 패키지를 통해 동기화 구현

# 13.34~13.36 wait( )과 notify( ), 예제1, 예제2, 

# 14. 람다와 스트림, # 14.1~14.6 람다식(Lambda Expression), 람다식 작성하기, 람다식의 예, 람다식은 익명 함수? 익명 객체!, 
함수형 인터페이스(Functional Interface), 함수형 인터페이스 타입의 매개변수, 반환타입

람다식
: Lambda expression, Anonymous function(익명함수)이라고 한다. method를 하나의 식(expression)으로 표현.

함수형 인터페이스(Functional Interface)
: 람다식을 다루기 위한, 인터페이스를 통해 람다식을 다루는 인터페이스. @FunctionalInterface

# 14.7~14.8 java.util.function 패키지, 예제

--🥤 기본적인 함수형 인터페이스 유형

함수형 인터페이스 / 메서드 : 설명

java.lang.Runnable / void run( )
: 매개변수 X, 반환값 X

Supplier<T> / T get( ) 
: 매개변수 X, 반환값 O

Consumer<T> / void accept( T t )
: 매개변수 O, 반환값 X

Function<T, R> / R apply( T t )
: 매개변수 하나에 결과 반환

Predicate<T> / boolean test( T t )
: 매개변수 하나, 반환값 boolean






----

--🥞 나누기 %

1 % 4인 경우, 몫이 0, 나머지는 1
2 % 4인 경우, 몫이 0, 나머지는 2
3 % 4인 경우, 몫이 0, 나머지는 3
4 % 4인 경우, 몫이 1, 나머지는 0

따라서 나누지 못하여 0이 몫이 된 경우에는 본래의 값이 그대로 나머지 값으로 된다.


--🌡 Java API 보기 
: 경로는 jdk17 -- lib -- src.zip 압축풀기

java.util 경로
: jdk17 -- lib -- src -- java.base -- java -- util

---

🥤 Eclipse에서 Git Clone 불러오기

Eclipse에서 
: Windows -- Perspective -- Open perspective -- Other -- Git

Clone a Git repository -- Git 주소 붙여넣기 -- Authentication에서 id, password 입력 -- Clone할 Branch 선택

Git에서
: Git repository -- Code -- Clone -- 주소 복사

🥤 Workspace Import 

File -- Import -- Project from Folder or Archive -- Directory -- Project 선택

---

🍭 cmd에서 한글 깨질 경우

chcp ( Changes the active console code page )

chcp 949를 chcp 65001( UTF-8 )로 바꾼다.

> chcp 65001


🍭 *.class의 JDK Version과 JVM Version이 다를 때

java.lang.unsupportedclassversionerror: ~ 와 같은 에러가 발생할 경우, Windows -> Preferences -> Java -> Compiler -> Compiler compliance level: 를 바꾸거나

고급 환경설정에서 JAVA_HOME과 PATH의 내용(경로)를 작성한 *.class의 JDK Version에 맞게 JDK를 설치해 변경한다. 


🍭 Eclipse Setting-@author change

eclipse.ini
: -Duser.name=manjuSnack 추가 혹은 Eclipse에서 Window / Preferences / Java / Code Style / Code Templates / Comments / Types에서

@author ${user}를 @author manjuSnack으로 수정

🍭 UTF-8 Setting

github 등에 commit, push할 때 UTF-8로 바꾸지 않으면 글자가 전부 깨진다. 만약 UTF-8로 바꾸지 않고 작성한 Code는 새로 작성해야 한다.

🎈 Prefereces 설정 
General -- Workspace - Text file encoding : Other : UTF-8
General - Content Types - Java Class File - Default encoding : UTF-8 후  Update
General - Editors - Text Edotprs -- Spelling - Dictionaries - Encoding : Default : UTF-8
Web - HTML Files, CSS Files 와 JSP Files에 The following encoding will apply : Encoding : ISO 10646/Unicode(UTF-8)로 각각 변경

---