---

Java의 정석(기초편)

설치와 설정, 에러, 생소한 내용 기술.

---

🍭 #ch1-5~6 자바 개발도구(JDK, Java Development Kit) 설치하기, 설정하기

🍭 Java Eclipse 설치
: JDK 11과 eclipse를 받는다. 실제로는 압축하여 USB 등에 옮겨 작업한다.

🍭 환경 변수 설정
시스템 환경 변수-시스템 변수-Path-jdk경로\bin-확인
: 환경 변수를 맨 위로 올려야 Database 작업 시 충돌 방지.

아래 JAVA_HOME을 먼저 설정한 후 PATH에는 %JAVA_HOME%\bin으로 작성하여도 된다.

시스템 환경 변수-시스템 변수-새로 만들기-JAVA_HOME,
: Tomcat이 JDK가 어디에 있는지 확인하기 위한 변수

Java Install 확인
: cmd ( Command Dos )에서 javac -version으로 java가 잘 설치되었는지 확인할 수 있다. 

만약, Java version과 Java(TM) SE Runtime Environment version이 상이한 경우에는 cmd에서 javac, java 명령어가 작동되지 않는다.

🍭 Java Spring 
Tomcat Install 확인 ( Command Line에서 )
: d: , cd D:\Coding\java\apache-tomcat-9.0.70\bin, startup으로 Tomcat이 잘 설치되었는지 확인할 수 있다.
맨 밑에 startup.Catalina.start ... 가 보이면 브라우저에서 localhost:8080을 가면 Tomcat에 대한 정보가 나온다.

: startup은 Server 열기, shutdown은 Server 닫기

STS도 압축만 풀고 내부에 STS를 실행시키면 된다.
: 만약에 실행과정 화면이 정상적으로 보이지 않으면 환경변수에 문제가 있다.

----

🍭 #ch1-7 자바 API( Application Programing Interface )

: Package 목록, Class 목록으로 All Class에 대한 내용을 참고할 수 있다.

Java API
: https://www.oracle.com/kr/java/technologies/javase-jdk8-doc-downloads.html 에서 다운로드 받는다.

: 경로\jdk-docs-all\docs\api에서 index.html로 Java API에 대한 내용을 알아볼 수 있다.

INDEX
: Java Class에서 method의 이름만 알고 있을 때 검색해 볼 수 있다.

----

🍭 #ch1-8~9 자바 첫 프로그램 작성하기, 자바 프로그램의 실행과정

work 폴더 생성
: 경로\jdk11\에서 work 폴더 생성해 둔다. 이곳에 .java 파일을 저장하는데 꼭 첫 문자는 대문자로 작성한다.

.java 확장자 보이게 하기
: 탐색기 / 파일 / 폴더옵션 / 보기 에서 '알려진 파일 형식의 파일 확장명 숨기기' 해제하고 '모든 폴더에 적용'

🍭 Compile ( javac.exe )

*.java 를 *.class로 기계어로 변환하는 일을 한다.

D:\Coding\java\jdk11\work 경로에서 
: javac 클래스명.java

.java 실행하기
D:\Coding\java\jdk11\work 경로에서 
: java 클래스명로 실행한다.

🍭 type Hello.class와 type Hello.java의 차이
 
: Command Line에서 type Hello.class으로 는 Compile된 기계라 읽기가 어렵지만 type Hello.java는 Code가 적힌 내용을 출력한다.

----

🍭 #ch1-10~12 Eclipse 설치하기, Eclipse로 Java 프로그램 개발하기, Eclipse의 View, Perspective, Workspace

🍭 Download할 Eclipse 종류.

Eclipse IDE for Java EE Developers
: Web Application을 만들 때 사용. 현재 이것으로 설치했다.

Eclipse IDE for Java Developers
: 기본적인 Java 기능만을 제공

Eclipse for Android Developes
: Android Studio를 대신 사용한다.

🍭 Eclipse 내부의 View, Perspective, Workspace

하나의 창을 View라 부르고, 구성 화면 전체를 Perspective(관점)라고 부른다.

Workspace
: Eclipse에서 작성한 파일이 저장되는 공간을 Workspace라고 한다. Eclipse가 처음 열릴 때 확인해 볼 수 있다.

🍭 Build 관련 메뉴 설명

: 소스파일(*.java)로부터 프로그램을 만들어 내는 전 과정

Project -- Build All

: Workspace의 모든 프로젝트를 빌드

Project -- Build Project

: 현재 Project를 Build ( 수동으로 .java를 .class 파일로 Compile 한다. )

Project -- Clean

: 이전 Build의 정보를 모두 삭제 ( 모든 소스 파일을 새로 Compile한다. )

Project -- Build Automatical

: .java File을 변경하고 매 저장할 때마다 .class를 알아서 생성해준다.

🍭 Navigator

탐색기와 같다. Compile 후 *.class를 확인할 수 있다.

Windows -- Show View -- Navigator

----

🍭 ch1-13~16장, Eclipse의 단축키, Eclipse의 자동완성 기능, Eclipse의 주석(Comment), 자주 발생하는 에러와 해결방법

🍭 Ex1_1 참고

ctrl+shift+L : 단축키 전체 목록보기
ctrl+ '+, -' : Font 크기 증가/감소
ctrl+D : 한줄 삭제
ctrl+alt+down : 행단위 복사

alt+shift+A : 멀티컬럼 편집(토글:같은 단축키로 On, Off)
alt+up, down : 선택한 행단위 이동
tab : 들여쓰기
shift+tab : 내어쓰기
ctrl+i : 들여쓰기, 내어쓰기 자동맞춤
ctrl+/ : 주석(토글) 
ctrl+space : 자동완성

🍭 단축키 재설정 방법
: Windows -- Preferences -- General -- Appearance -- Keys-copy line 검색(행단위 복사일 경우) -- Binding 에서 단축키 설정 -- Apply and Close

🍭 자동완성 재설정 방법
Windows -- Preferences -- Java -- Editor -- Templates -- sysout(바꾸고 싶은 자동완성 이름 찾아 선택) -- Edit -- Name 변경(sysout를 sop로 바꿈) -- Rename -- Apply Close

🍭 자동완성 확장 방법
Windows -- Preferences -- Java -- Editor -- Content Assist -- Auto Activation treggers for Java에서 . 를 .abcdefghijklmnopqrstuvwxyz로 바꾸고 저장

----

-- 🍭 #ch01-17~19장 책의 소스와 강의자료 다운로드, Eclipse 소스파일 가져오기, 내보내기

🍭 소스파일 불러오기
Eclipse 좌측 View에 Package Workspace에서 빈공간 우클릭 import-General-Existing Projects into Workspace-Select root directory로 Directory 찾기, Copy projects into workspace 체크(복사본으로 불러오기)

🍭 소스파일 내보내기
Eclipse 좌측 View에 Package Workspace에서 빈공간 우클릭 export-General-Archive file-Export할 Project 선택, to archive file 경로 선택 

---

--🍭 #ch7-12~14 패키지( package ), 패키지의 선언, 클래스 패스( Classpath )

rt.jar
: runtime.jar로 runtime이라는 말 그대로 실행을 담당하는 클래스를 묶어놓은 압축파일. 
Java 9부터는 rt.jar이 아닌 module 개념을 도입하여 사용한다.

🍭 .java 파일이 저장된 탐색기 경로 보기

.java -- context menu -- Show in -- System Explorer

🍭 Class 파일 찾아 실행하기

cmd.exe에서 위의 .java 파일이 저장된 탐색기 경로에 \bin 경로가서 `java <package명.class명>`으로 실행시킬 수 있다.

🍭 환경변수에 CLASSPATH를 등록하기

: 시스템 속성 -- 환경변수 -- CLASSPATH와 경로를 입력하여 만든다. 혹은 cmd.exe에서 `set classpath`를 사용해서 추가한다.

set classpath=<`\bin 경로`>;<추가하고 싶은 경로>

참고로 ` ; `로 여러 경로를 같이 적어줄 수 있다.

---

--🍭 생소한 Method()

print()

println()

printf()

if()

if-else()

switch()

for()

while()

do-while()

break;

continue;

name : for 또는 while
: 이름붙은 반복문으로 break name; 혹은 continue name;으로 둘 이상의 for문, while문, do-while문을 벗어날 수 있다.

Interger.toBinaryString(숫자) : Integer.toBinaryString()는 값을 2진수로 출력

Integer.parseInt(문자열) : 문자열을 정수로 변환

Double.parseDouble(문자열) : 문자열을 실수로 변환

charAt(0) : 문자열을 문자로 바꿀 수 있다. 예를 들면  변수 Literal.charAt(0) 혹은 "3".charAt(0)으로 '3'으로 바꿀 수 있다.

변수.equals("문자열") : 대소문자 구분하며 변수와 문자열이 같은지 비교한다.

변수.equalsIgnoreCase("문자열") : 대소문자 구분하지 않으며 변수와 문자열을 같은지 비교한다. 

--🍭 Math Class

Math.random() : 난수를 만들어 낸다. 이때 난수는 실수이다.

Math.round() : 실수의 소수점 첫째자리에서 반올림하여 정수로 표현한다.

Math.sqrt(변수)
: 제곱근(√ : root)을 나타낸다.

Math.log(변수)
: 지수함수의 역함수 ( log ), 예를 들어, 3^4 = 81일때, 이때 4가 log이다.

--🍭 Arrays Class -- 배열의 출력, 비교, 복사, 정렬

Arrays.toString(배열)
: 1차원 배열의 모든 요소를 문자열로 변환

Arrays.deepToString(다차원배열)
: 2차원, 다차원 배열의 모든 요소를 문자열로 변환

Arrays.equals( 배열1, 배열2 )
: 1차원 배열1과 배열2의 모든 요소를 비교

Arrays.deepEquals( 배열1, 배열2 )
: 2차원, 다차원 배열1과 배열2의 모든 요소를 비교

타입[ ] 새 배열 = Arrays.copyOf( 복사할 배열, 복사할 배열.length )
: 복사할 배열의 전체 혹 복사할 요소의 갯수만큼 복사해서 새로운 배열에 반환

타입[ ] 새 배열 = Arrays.copyOfRange( 복사할 배열, from, to )
: 복사할 배열을 from ~ to만큼의 범위( index )로 복사해서 새로운 배열에 반환. 단, to의 값-1 만큼만 출력한다.

Arrays.sort( 배열 )
: 배열 내 요소를 오름차순으로 정렬한다.

--🍭 String Class

charAt(int index)
: 문자열에서 해당 위치(index)에 있는 문자를 반환. 배열에서 '배열이름[index]'로 값을 가져오는 것과 같다.

length( )
: 문자열의 길이를 반환

substring(int from, int to)
: 문자열에서 해당 범위(from ~ to)의 문자열을 반환하며 마지막 to에 대한 범위는 포함되지 않는다.

equals(Object obj)
: 문자열의 내용이 같은지 확인한다. 같으면 결과는 true, 다르면 false이다. 또한 대소문자를 구분한다.

equalsIgnoreCase( )
: equals( )와는 다르게 대소문자를 구분하지 않고 문자열의 내용이 같은지 확인한다.

toCharArray( )
: 문자열(String)을 문자배열(Char [ ])로 변환해서 반환한다. 

--🍭 Scanner Class

.nextInt() : 정수를 입력
.nextfloat() : 실수를 입력
.nextLine() : 행단위로 문자열을 입력

--🍭 메모 후 정리중

this
: 클래스 내 멤버변수를 참조

this( )
: 클래스 내 생성자를 호출

class 자손클래스 extends 조상클래스
: 조상클래스로부터 멤버변수와 메서드(method)를 상속받는 자손클래스

super
: 상속받은 조상클래스 내 멤버변수를 참조 

super( )
: 상속받은 조상클래스 내 생성자를 호출

Overloading
: 매개변수의 개수와 타입이 다른 같은 이름의 생성자(constructor) 혹 메서드(method)를 정의하는 것

Overriding
: 상속받은 조상클래스 내 메서드를 재정의하는 것 

package 패키지명
: 클래스를 분류해 중복된 이름이 없도록 규정한 클래스의 묶음

import 패키지명.클래스명;
: 클래스이름의 패키지명을 생략하기 위함

import 패키지명.*;
: 해당 패키지 안에 클래스이름의 패키지명을 모두 생략하기 위함 

import static 패키지명.클래스명;
: class 내부의 static class를 import할 때 패키지와 클래스 이름까지 생략하여 사용할 수 있다.

public, protected, (default), private
: 접근제어자( access modifier )를 일컫는다.

static, final, abstract, native, transient, synchronized, volatile, strictfp
: 그 외 제어자( modifier )를 일컫는다.

static
: 인스턴스(객체)를 생성하지 않고도 모든 인스턴스에서 사용할 수 있는 멤버변수와 메서드, 초기화 블록의 앞에 작성한다.

final
: 변경과 상속을 줄 수 없는 클래스, overriding이 불가능한 메서드, 값을 변경할 수 없는 멤버변수와 지역변수의 앞에 작성된다. 그러나 참조된 객체 내부에서의 변경은 가능하다.

abstract
: 인스턴스를 생성할 수 없는 메서드의 선언부만 작성한 실제 수행내용은 구현되지 않은 추상 메서드 혹 추상메서드가 포함된 클래스. 미완성 메서드.
아래 내용 중 abstract class의 설명 참고

---

--💬 추후 학습할 내용!

native ( 본래의 )
: JVM ( Java Virtual Machine ) 밖에서 C/C++ Code로 메소드를 정의할 때 쓰는 키워드

transient ( 일시의 )
: Object Stream을 만들 때 값을 전달하지 않도록 숨기는 키워드

synchronized ( 동기화된 )
: 멀티스레드에서 스레드 충돌을 막기 위해 스레드 락(Lock)을 거는 키워드

volatile ( 휘발성의 )
: 컴파일러(Compiler) 최적화를 막아 멀티스레드 처리에 요긴하게 쓰이는 키워드

strictfp ( Strict Floating Point, 엄격한 부동소숫점 )
: 클래스와 인스턴스 내에서 엄격한 부동소숫점 연산을 하도록 하는 키워드. Java 17부터는 영향이 없다.

---

public
: 접근 제한이 없다.

protected
: 같은 패키지 내에서와 더불어 다른 패키지의 자손 클래스에서 접근이 가능하다.

(default)
: 아무 접근 제어자도 작성하지 않은 경우이며 같은 패키지 내에서만 접근이 가능하다. "package-private"라는 이름으로 통용되곤 한다.

private
: 같은 클래스 내에서만 접근이 가능하다.

data hiding
: 외부로부터 접근을 제한하여 데이터가 유효한 값을 유지하도록 하는 것

캡슐화(encapsulation)
: 외부로부터 접근을 제한하거나 외부로 노출시키지 않는 것

get멤버변수이름
: 멤버변수의 값을 읽는 메서드. 간단히 getter라 부른다.

set멤버변수이름
: 멤버변수의 값을 변경하는 메서드. 간단히 setter라 부른다.

다형성(polymorphism)
: Overriding이 대표적인 예시이며, 조상 클래스의 타입과 참조 변수로 자손클래스의 인스턴스를 생성해 참조하여 조상 클래스의 인스턴스 멤버들만 사용가능

쉽게 말해, "부모된 도리로 자식의 밥 숟가락을 뺏지 않는다. 반대의 경우 자식이 시건방지다"

참조변수의 형변환
: 조상 타입의 참조변수로는 조상 클래스의 인스턴스 내 멤버들만 사용 가능
자손 타입 → 조상 타입은 형변환을 생략가능하나 조상 타입 → 자손타입은 생략불가하다. 

쉽게 말해, "할배, 할매 꺼도 내꺼! 엄마, 아빠꺼도 내꺼! 그러나! 내꺼는 내꺼!"

`참조변수 instanceof 타입(클래스명)`
: 참조변수를 형변환이 가능한지 참조변수가 참조하고 있는 인스턴스의 실제 타입을 확인

쉽게 말해, "늬집 자식인지"

매개변수의 다형성
조상타입(조상클래스)의 참조변수를 매개변수(parameter)로 사용하여 자손타입의 객체 내 멤버를 매개변수로 참조하는 것, 
불러올 때에는 자손타입의 객체를 생성하는 문구를 인자(Argument)로 보낸다.

쉽게 말해, "엄마, 아빠가 다 알아서 해줄게"

Vector 클래스
: 배열의 크기를 알아서 관리해주는 클래스

--💬 추후 학습할 내용!
ArrayList와 마찬가지로 배열의 길이를 동적으로 활용할 수 있다는 점은 같지만, Vector는 Thread-block이 구현되어 있다. 
비슷하게 hashtable이 hashMap에 Thread-block 기능이 있으며 최근 버전에서는 Collections.syncronizedCollection, Collections.synchronizedSortedMap 등의 메소드로 내부 구현을 그대로 활용하며 Thread-block 기능을 덧붙일 수 있다.

---

추상클래스( abstract class )
: 상속을 통해 구현하고자 하는 미완성 메서드와 생성자, 멤버변수를 포함하고 있는 클래스이며 따라서 인스턴스는 생성하지 못한다.

쉽게 말해, "후루꾸 클래스"

추상메서드( abstract method )
:  자손클래스에서 상속을 통해 구현하고자 하는 미완성 메서드이며, 구현부가 없기에 { }는 생략한 ` abstract 리턴타입 메서드이름( ); `으로 작성한다.

쉽게 말해, "후루꾸 메서드"

---

인터페이스( interface )
: 오직 추상메서드와 상수만을 멤버로 가질 수 있는 추상화 정도가 높은 추상클래스, 접근제어자(access modifier)로 public 또는 default만을 사용한다. 밑그림만 그려져 있는 "기본 설계도" 

작성법
: interface 인터페이스 이름 {
   public static final 타입 상수이름 = 값;
   public abstract 메서드이름(매개변수목록);
}

단, static method와 default method는 앞에 "public abstract"를 쓰지 않아도 된다. JDK 1.8 부터

쉽게 말해, "계획이 있는 후루꾸 클래스"

인터페이스의 상속
: 인터페이스는 인터페이스로만 상속이 되며, 클래스와는 달리 다중상속이 가능하다.

class 클래스이름 implements 인터페이스이름 { ... }
: 인터페이스를 상속받은 클래스에서 인터페이스를 구현하며, 인터페이스의 일부만을 구현하고자 할 경우엔 class 앞에 sbstract를 붙여 다시 추상클래스로 선언해야 한다.

class 클래스이름 extends 조상클래스 implements 인터페이스이름 { ... }
: 상속과 구현을 동시에 할 수 있다.

인터페이스의 다형성
: 매개변수의 다형성과 같이 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다. 

리턴타입이 인터페이스라는 것
: 리턴타입이 인터페이스일 경우 메서드 내 해당 인터페이스를 구현한 클래스의 인스턴스가 가진 주소 값을 반환한다. 

인터페이스의 장점
: 하나의 인터페이스로 이를 구현하는 클래스를 동시에 작성할 수 있고 보다 일관된 코드로 정형화시킬 수 있다. 
서로 상속관계에 있지 않은 클래스를 하나의 인터페이스로 간접적인 관계를 맺어 줄 수 있다.

인터페이스에서의 디폴트 메서드(default method)
: 인터페이스에서의 추상 메서드가 아닌 일반 메서드와 역할이 같으며 선언부와 구현부 모두 갖고 있다, "default 리턴타입 메서드이름( ) { ... }"로 작성한다.

여러 인터페이스의 디폴트 메서드 간의 충돌
: 구현한 클래스에서 디폴트 메서드를 오버라이딩한다.

디폴트 메서드와 조상클래스의 메서드 간의 충돌
: 조상 클래스의 메서드만 상속되고 디폴트 메서드는 무시된다.

내부 클래스(inner class)
:  A 내부에 B가 있을 경우 클래스 A를 외부 클래스(outer class), B를 내부 클래스(inner class)라 한다.

내부 클래스의 종류
: 인스턴스 클래스(instance class), 스태틱 클래스(static class), 지역 클래스(local class), 익명 클래스(anonymous class)

인터턴스 클래스, 스태틱 클래스, 지역클래스는 변수의 선언위치와 동일한 유효범위(scope)와 접근성(accessibility)를 갖는다.

익명 클래스(anonymous class)
: 클래스 선언과 객체(인스턴스)의 생성을 동시에 하는 이름없는 클래스. 일회용

--🌡 내부 클래스의 제어자와 접근성
: 클래스 앞에는 (default)와 public만 되지만 내부 클래스에서는 private, protected, (default), public이 가능하다.

: JDK1.8의 경우, static 클래스에서만 static 멤버를 정의할 수 있다. 상수인 final static 멤버는 내부 클래스 중 Instance, static, local 클래스 안에 전부에 정의할 수 있다.

: 외부 클래스 내 private 멤버 변수를 내부 클래스에서도 참조할 수 있다.
 
: 외부 클래스의 메서드 내 내부 클래스(지역 클래스)는 지역변수보다 더 오래 존재할 수 있지만, 메서드 수행 뒤엔 지역변수가 사라지며 constant pool에서 상수가 따로 저장되어 final이 붙은 변수(상수)만 접근가능하다.
JDK1.8부터는 final이 생략 가능하므로 지역변수가 상수로 간주된다. 

: Compile한 후 class 파일명은 "외부클래스명$내부클래스명.class" 혹은 "외부클래스$숫자지역클래스.class"로 생성된다. 숫자는 지역클래스 내 같은 이름의 method 순번.

: 내, 외부 클래스에 선언된 변수의 이름이 같을 땐 내부 클래스에는 "this.멤버변수" 로 쓰고 외부클래스에서는 "외부클래스명.this.멤버변수"로 쓴다.

익명 클래스(anonymous class)
: 변수와 메서드에는 이름이 있듯이 "그 이름"이 없는 일회용 클래스, 클래스의 선언와 생성을 동시에 한다.

new 조상클래스이름( ) { //멤버선언... } 또는 new 구현인터페이스이름( ) { //멤버선언... }으로 작성한다.

예, 이름이 없기 때문에 조상클래스( )는 Object( )가 된다.

awt ( abstract window toolkit )
: Java의 윈도우 프로그래밍 툴

프로그램의 오류
: 컴파일 에러(compile-time error), 런타임 에러(runtime error), 논리적 에러(logical error)

컴파일 에러(compile-time error)
: compile 하는 과정 중 발생한 에러

런타임 에러(runtime error)
: 실행도중에 발생하는 에러. 에러(error)와 예외(exception)가 있다. 

이때 에러(error)는 메모리부족(OutOfMemoryError) 혹 스택오버플로우(StackOverflowError)와 같이 일단 발생하면 복구할 수 없는 심각한 오류
예외(exception)는 수습이 가능하다.

논리적 에러(logical error)
: 의도한 것과 다르게 동작하는 것

Exception과 RuntimeException

: Exception클래스는 사용자의 실수와 같은 외적인 요인의 의한 예외, RuntimeException클래스는 프로그래머의 실수로 발생하는 예외

try-catch문

: 예외처리(exception handling), 예외 발생 시 대비한 코드를 작성하며 비정상 종료를 막고 정상적인 실행상태를 유지한다.
만약 JVM의 예외처리기(UncaughtExceptionHandler)가 처리되지 못한 예외(uncaught exception)가 있다면 받아서 그 원인을 화면에 출력한다.

---

🍭 cmd에서 한글 깨질 경우

chcp ( Changes the active console code page )

chcp 949를 chcp 65001( UTF-8 )로 바꾼다.

> chcp 65001


🍭 *.class의 JDK Version과 JVM Version이 다를 때

java.lang.unsupportedclassversionerror: ~ 와 같은 에러가 발생할 경우, Windows -> Preferences -> Java -> Compiler -> Compiler compliance level: 를 바꾸거나

고급 환경설정에서 JAVA_HOME과 PATH의 내용(경로)를 작성한 *.class의 JDK Version에 맞게 JDK를 설치해 변경한다. 


🍭 Eclipse Setting-@author change

eclipse.ini
: -Duser.name=manjuSnack 추가 혹은 Eclipse에서 Window / Preferences / Java / Code Style / Code Templates / Comments / Types에서

@author ${user}를 @author manjuSnack으로 수정

---

--🍭 Java의 정석 학습과정

--🍭 2023. 02. 18 내용, 1일차

- `Kokoa Clone 다시 만들기` 완성한 이후 Java의 정석 기초편 학습 내용 이후로 학습진행

   : Chapter 6 객체지향언어부터 복습 후 이어 진행. 

- 이전 학습 방법과 다른 방법으로 진행.
   
  : 동영상 강의 우선이 아닌 책 위주로 학습

---

--🍭 2023. 02. 19 내용, 2일차

- 객체지향언어ⅰ / Chapter 6-22 ~ 7-14, 호출스택(call stack) ~ 클래스 패스(classpath)  

---

--🍭 2023. 02. 20 내용, 3일차

- 객체지향언어ⅱ / Chapter 7-15 ~ 7-32, import문 ~ 추상메서드(abstract method)

---

--🍭 2023. 02. 21 내용, 4일차

- 객체지향언어ⅱ / Chapter 7-33 추상클래스의 작성 ~ 예외처리 / Chapter 8-3 Exception과 RuntimeException 