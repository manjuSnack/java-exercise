---

Java의 정석(기초편)

아래 학습한 내용 기술.

---

🍘 #ch1-1 자바(Java)란?

🍘 구성
: 실행환경( JRE, Java Run-time Environment ) + 개발도구(JDK, Java Development Kit) + 라이브러리(API, Application Programing Interface)

도구
PC Application
: eclipse, InteliJ

Web Application
: Spring, Spring Boot

빅데이터
: hadoop

게임
: Minecraft

----

🍘 #ch1-2 자바의 역사

JDK 1.0 ( 1996 )
J2SE ( 1998 )
: Java2라고도 부른다.

J2SE ( Standard Edition ) : 일반
J2ME ( Micro Edition ) : 소형 기기 ( ATM )
J2EE ( Enterprise Edition ) : 대기업용, 서버용

J2SE 5.0 ( 2004 )
: J2SE 1.5라고도 부른다.

Java SE 8 ( 2014 )

🍘 Applet
: 1996년 1월, Java의 출시 초기에 Web Application으로 사용하다 보안상의 이유로 Servlet과 JSP( Java Server Page)로 사용하게 되었다.

----

🍘 #ch1-3 자바의 특징

배우기 쉬운 객체지향 언어
: C++, Java, Python, Javascript가 있다.

자동메모리 관리
: Garbage collector가 자동적으로 메모리를 관리해준다. C++는 개발자가 직접 메모리를 회수해야 Code를 작성해주어야 한다.

Multi-thread를 지원
: 채팅을 하면서 파일을 주고받는 기능 등 여러 기능을 구현하게 해준다.

풍부한 라이브러리로 쉽게 개발 가능

운영체제에 독립적
: Java는 운영체제와는 별개로 프로그램이 실행된다. JVM ( Java Virtual Machine )에 의해 실행한다.

----

🍘 #ch1-4 자바 가상 머신 ( JVM, Java Virtual Machine )

: Windows mediaplayer나 Winamp와 같이 Java를 실행하기 위한 가상 기계(소프트웨어)라고 한다.

Byte Code를 기계어로 변화해주는 JIT Compile와 여러 기능으로 Compile 속도의 격차를 많이 줄였다.

참고로, JVM은 종속적이라 OS 별로 실행가는한 JVM이 필요하다.

----

🍘 #ch1-5~6 자바 개발도구(JDK, Java Development Kit) 설치하기, 설정하기

🍘 Java Eclipse 설치
: JDK 11과 eclipse를 받는다. 실제로는 압축하여 USB 등에 옮겨 작업한다.

🍘 환경 변수 설정
시스템 환경 변수-시스템 변수-Path-jdk경로\bin-확인
: 환경 변수를 맨 위로 올려야 Database 작업 시 충돌 방지

시스템 환경 변수-시스템 변수-새로 만들기-JAVA_HOME,
: Tomcat이 JDK가 어디에 있는지 확인하기 위한 변수

Java Install 확인
: cmd ( Command Dos )에서 javac -version으로 java가 잘 설치되었는지 확인할 수 있다. 

🍘 Java Spring 
Tomcat Install 확인 ( Command Line에서 )
: d: , cd D:\Coding\java\apache-tomcat-9.0.70\bin, startup으로 Tomcat이 잘 설치되었는지 확인할 수 있다.
맨 밑에 startup.Catalina.start ... 가 보이면 브라우저에서 localhost:8080을 가면 Tomcat에 대한 정보가 나온다.

: startup은 Server 열기, shutdown은 Server 닫기

STS도 압축만 풀고 내부에 STS를 실행시키면 된다.
: 만약에 실행과정 화면이 정상적으로 보이지 않으면 환경변수에 문제가 있다.

----

🍘 #ch1-7 자바 API( Application Programing Interface )

: Package 목록, Class 목록으로 All Class에 대한 내용을 참고할 수 있다.

Java API
: https://www.oracle.com/kr/java/technologies/javase-jdk8-doc-downloads.html 에서 다운로드 받는다.

: 경로\jdk-docs-all\docs\api에서 index.html로 Java API에 대한 내용을 알아볼 수 있다.

INDEX
: Java Class에서 method의 이름만 알고 있을 때 검색해 볼 수 있다.

----

🍘 #ch1-8~9 자바 첫 프로그램 작성하기, 자바 프로그램의 실행과정

work 폴더 생성
: 경로\jdk11\에서 work 폴더 생성해 둔다. 이곳에 .java 파일을 저장하는데 꼭 첫 문자는 대문자로 작성한다.

.java 확장자 보이게 하기
: 탐색기 / 파일 / 폴더옵션 / 보기 에서 '알려진 파일 형식의 파일 확장명 숨기기' 해제하고 '모든 폴더에 적용'

🍘 Compile ( javac.exe )

*.java 를 *.class로 기계어로 변환하는 일을 한다.

D:\Coding\java\jdk11\work 경로에서 
: javac 클래스명.java

.java 실행하기
D:\Coding\java\jdk11\work 경로에서 
: java 클래스명로 실행한다.

🍘 type Hello.class와 type Hello.java의 차이
 
: Command Line에서 type Hello.class으로 는 Compile된 기계라 읽기가 어렵지만 type Hello.java는 Code가 적힌 내용을 출력한다.

----

🍘 #ch1-10~12 Eclipse 설치하기, Eclipse로 Java 프로그램 개발하기, Eclipse의 View, Perspective, Workspace

🍘 Download할 Eclipse 종류.

Eclipse IDE for Java EE Developers
: Web Application을 만들 때 사용. 현재 이것으로 설치했다.

Eclipse IDE for Java Developers
: 기본적인 Java 기능만을 제공

Eclipse for Android Developes
: Android Studio를 대신 사용한다.

🍘 Eclipse 내부의 View, Perspective, Workspace

하나의 창을 View라 부르고, 구성 화면 전체를 Perspective(관점)라고 부른다.

Workspace
: Eclipse에서 작성한 파일이 저장되는 공간을 Workspace라고 한다. Eclipse가 처음 열릴 때 확인해 볼 수 있다.

🍘 Build 관련 메뉴 설명

: 소스파일(*.java)로부터 프로그램을 만들어 내는 전 과정

Project > Build All

: Workspace의 모든 프로젝트를 빌드

Project > Build Project

: 현재 Project를 Build ( 수동으로 .java를 .class 파일로 Compile 한다. )

Project > Clean

: 이전 Build의 정보를 모두 삭제 ( 모든 소스 파일을 새로 Compile한다. )

Project > Build Automatical

: .java File을 변경하고 매 저장할 때마다 .class를 알아서 생성해준다.

🍘 Navigator

탐색기와 같다. Compile 후 *.class를 확인할 수 있다.

Windows > Show View > Navigator

----

🍘 ch1-13~16장, Eclipse의 단축키, Eclipse의 자동완성 기능, Eclipse의 주석(Comment), 자주 발생하는 에러와 해결방법

🍘 Ex1_1 참고

ctrl+shift+L : 단축키 전체 목록보기
ctrl+ '+, -' : Font 크기 증가/감소
ctrl+D : 한줄 삭제
ctrl+alt+down : 행단위 복사

🍘 단축키 재설정 방법
: Windows-Preferences-General-Appearance-Keys-copy line 검색(행단위 복사일 경우)-Binding 에서 단축키 설정-Apply and Close

alt+shift+A : 멀티컬럼 편집(토글:같은 단축키로 On, Off)
alt+up, down : 선택한 행단위 이동
tab : 들여쓰기
shift+tab : 내어쓰기
ctrl+i : 들여쓰기, 내어쓰기 자동맞춤
ctrl+/ : 주석(토글) 
ctrl+space : 자동완성

🍘 자동완성 재설정 방법
Windows-Preferences-Java-Editor-Templates-sysout(바꾸고 싶은 자동완성 이름 찾아 선택)-Edit-Name 변경(sysout를 sop로 바꿈)-Rename-Apply Close

🍘 자동완성 확장 방법
Windows-Preferences-Java-Editor-Content Assist-Auto Activation treggers for Java에서 . 를 .abcdefghijklmnopqrstuvwxyz로 바꾸고 저장

----

🍘 #ch01-17~19장 책의 소스와 강의자료 다운로드, Eclipse 소스파일 가져오기, 내보내기

🍘 소스파일 불러오기
Eclipse 좌측 View에 Package Workspace에서 빈공간 우클릭 import-General-Existing Projects into Workspace-Select root directory로 Directory 찾기, Copy projects into workspace 체크(복사본으로 불러오기)

🍘 소스파일 내보내기
Eclipse 좌측 View에 Package Workspace에서 빈공간 우클릭 export-General-Archive file-Export할 Project 선택, to archive file 경로 선택 

----

🍘 #ch2-1~2 화면에 글자 출력하기-print()와 println(), 덧셈 뺄셈 계산하기

print()
: 줄바꿈하지 않고 출력. Console 창에서 커서가 있는 위치가 print()로 출력할 위치이다.

println()
: 줄바꿈하여 출력

----

🍘 ch2-3 변수의 선언과 저장

Ex2_6.java 참고

🍘 변수(variable)란?

: 수학적 개념의 변하는 수가 아닌 하나의 값을 저장할 수 있는 메모리 공간을 뜻한다.
이미 값이 저장된 변수에는 새로운 값을 저장하면 기존의 값은 지워지고 새로 저장된 값만 남는다.

🍘 변수의 선언

변수의 선언 이유
: 값(data)을 저장할 공간을 마련하기 위해서

🍘 변수의 선언 방법

'변수타입 변수이름;' 으로 작성한다. 

예를 들면, int age;
: 정수(Integer) 타입의 변수 age를 선언

🍘 변수에 값 저장하기

변수이름 = 저장할 값;

🍘 변수의 초기화

: 변수에 처음으로 값을 저장하는 것.

🍘 변수의 종류

Class 변수
Instance 변수
Local variable (지역변수)

단, 지역변수(Local variable)의 경우에는 초기화를 꼭 해주어야 한다. 그 외 Class 변수, Instance 변수에 경우에는 초기화하지 않아도 된다.

🍘 변수의 값 읽어오기

초기화 한 후 변수의 이름으로 값을 불러올 수 있다.

----

🍘 #ch2-4 변수의 타입

Ex2_6.java 참고

: 저장할 값의 타입에 의해 결정하며 저장할 값과 일치하는 타입으로 변수를 선언해야 한다.

🍘 값의 타입, 문자와 실수 그리고 논리

🍘 문자(character), 문자열(String)

: char, String

String은 타입이 아니라 Class이다. String str = new String();로 생성해야 하지만, String() Class 같은 경우에는 new 연산자는 생략해도 된다.

🍘 숫자

정수(integer)
: byte, short, int, long

숫자 20억이 넘을때는 long을 사용한다.

실수 (floating-point number)
: float, double

float는 오차없이 7자리수, double은 15자리수이다.

🍘 논리

: Boolean

Boolean은 true와 false의 값을 가지고 있다.

---

🍘 #ch2-5 상수와 리터널

: 상수(Constant)는 한 번만 값을 저장 가능한 변수이며 변수(variable)과는 다르게 이후 변경은 불가능하다. 작성하는 방법은 아래와 같다.

final 변수타입 변수명(대문자) = 초기화할 값;

🍘 리터럴(Literal, 문자 그대로의)

: 상수를 수학적 개념이 아닌 '한 번만 값을 저장하는 변수'라고 의미를 달리 두었기 때문에 Literal을 사용한다.
Literal은 그냥 값을 의미한다.


---

🍘 #ch2-6, 리터럴의 타입과 접미사

VarEx3.java 참고

변수에 타입은 저장될 값의 타입(Literal의 타입)에 의해 결정된다.

접미사가 굳이 필요없는 기본형 정수와 실수는 int와 double이다.

정수형에 ob0101에서 ob는 2진수 literal를 뜻한다.
long은 접미사 'l' 혹 'L'을 붙이고 float는 접미사 'f' 혹 'F'를 붙인다. 접두사인 0b(2진수), 0(8진수), 0x(16진수) 또한 대소문자를 구별하지 않는다.

JDK 1.7 이후부터 정수형 literal 사이에 '_'로 구분자를 넣을 수 있다. 

🍘 소수점과 제곱
정수형 literal에 소수점 ' . '을 나타내는 경우 실수형 literal로 바뀐다. 1e3의 경우에는 10의 3승을 뜻하는 literal이다.

🍘 변수와 리터럴의 타입 불일치

범위가 '변수 > 리터럴'인 경우에는 에러가 없다.

int > char
long > int
double > float

그러나 '변수 < 리터럴' 인 경우에는 에러가 발생

int i = 30_0000_0000; 
: int의 범위 20억을 벗어난다.

long < float
float < double

위에 3가지는 에러가 발생

byte, short에 int literal도 저장가능하지만 byte와 short는 literal이 별도로 존재하지 않아 
int 타입의 literal을 사용하지만 byte와 short의 범위를 초과시 에러가 발생 

---

🍘 #ch2 -7~8, 문자, 문자열 리터럴, 문자열 결합

VarEx3.java 참고.

덧셈 연산자(+)는 피연산자가 모두 숫자일 때 두 수를 더하지만 어느 한 쪽이 String인 경우 다른 한쪽을 String으로 변환 후 두 String을 결합한다.

---

🍘 #ch2-9, 두 변수 바꾸기

Ex2_8.java 참고

변수를 하나의 컵이라고 가정하고 우유와 주스를 바꿔 담고자 할 때 빈 컵이 필요할 것이다. 
빈 컵을 이용해 우유와 주스를 바꿔 담을 수 있다. 이처럼 임시로 저장할 변수가 하나 더 필요하다.

---

🍘 #ch2-10, 기본형과 참조형

앞서 ch.2-4 변수타입 참고.

Java는 C언어와 달리 참조형 변수(Reference Type) 간의 연산을 할 수 없으므로 실제 연산은 기본형(Primitive type)의 변수만으로 계산한다.

🍘 자료형(data type)에는 기본형과 참조형인 2가지가 있다.

🍘 기본형(Primitive type)
: 오직 8개 (논리: boolean / 문자형 : char / 정수형 : byte, short, int, long / 실수형 : float, double)

🍘 참조형(Reference type)
: 기본형을 제외한 나머지로써, String, System 등
참조형은 갯수가 무한대이다. ch 6장 참고

메모리 주소를 저장(4 byte 또는 8byte)
4 byte의 경우 40억의 변수(40억 byte인 약 4GB)를 사용할 수 있고 32bit JVM은 4byte를 사용한다.
8 byte의 경우 160경(1600만 TB)의 변수를 사용할 수 있고 64bit JVM은 8byte를 사용한다.

---

🍘 #ch2-11장, 기본형의 종류와 범위

Ex2_6.java 참고

🍘 기본형(Primitive type)의 종류와 크기

논리형, 문자형, 정수형, 실수형이 있다.

boolean은 조건식과 논리적 계산에 사용된다.
char는 유니코드(2byte)를 사용하며 C언어에서는 1byte를 사용한다.
byte는 1byte이며 주로 이진데이터를 다루는데 사용된다.
short는 2byte이며 c언어와의 호환을 위해 추가되었지만 잘 쓰이지 않는다.
int는 4byte로 정수형에서 default이다.
long은 8byte로 int보다 높은 값을 사용할 때 쓰인다.
float는 부동소수점(floating point, 떠다니는 점)이라 불리며 4byte이다.
double은 실수형에서 default이며 float보다 정밀도가 2배이며 8byte이다.

🍘 기본형(Primitve type)의 표현범위

1 bit는 0, 1로만 구성되어 있다.
1 byte는 8bit로 구성되어 있다.

n비트로 표현할 수 있는 값의 개수
: 2의 n승 개

n비트로 표현할 수 있는 부호없는 정수의 범위
: 0 ~ (2의 n승-1)

n비트로 표현할 수 있는 부호있는 정수의 범위
: -2의 n-1승 ~ (2의 n-1승-1)

byte의 경우에는 0을 포함해야 하기 때문에 부호없는 정수에 경우 0~255(256개)이고, 부호있는 정수에 경우에는 -128 ~ 127(256개)까지이다.

byte는 맨 좌측 bit를 부호비트(sign bit)라고 하며 0 (양수), 1(음수)를 표현하기 위해 쓰이기 때문에 2의 7승인 256개로 값을 표현한다.

short는 2byte로 부호가 있는 정수의 범위로써 -2의 15승 ~ (2의 15승-1)으로 -32,768 ~ 32,767의 값이 쓰인다.

char는 2byte로 부호가 없는 정수의 범위로써 0 ~ 65,535의 값이 쓰인다. \u0000 ~ \uffff까지 표현한다.

int는 4byte로 부호가 있는 정수의 범위로써 -2의 31승 ~ (2의 31승-1), 2의 31승은 2의 10승을 3번 곱한 뒤 2를 곱한 값을 표현한다.
2E10(2의 10승)은 약 1,024이며 10의 3승이다. 고로 양수만으로 2 x E9 = 약 20억으로 -20억 ~ 20억까지 표현할 수 있다.

long은 8byte로 부호가 있는 정수의 범위로써 -2의 63승 ~ (2의 63승-1), 2의 63승은 2의 3승과 2의 60승을 곱한 값으로, 8 x 10의 18승인 800경이다.
고로 -800경 ~ 800경까지를 표현할 수 있다. 

만약, 800경을 넘는 수를 사용할 경우 BigInteger라는 Class를 사용해야 한다. ch 9장에서 설명한다.

float는 양수만을 표현할 경우 1.4E-45 ~ 3.4E38, 단 -1.4E-45 ~ 1.4E-45는 표현할 수 없는 범위이다.
float는 4byte로 부호(Sign bit) 1개, 지수 8개, 가수 23개(정규화로 24개까지 표현할 수 있다)로 구성되어 있다.  
가수는 3.4를 가리키고 지수는 E38을 가리킨다. 오차 없는 범위는 값을 7자리만을 표현할 수 있다. 
가수의 자리 수 24인 2의 24는 E7(10의 7승)보다 크고 E8(10의 8승)보다 작기 때문에 오차범위는 7자리가 된다.

double은 양수만을 표현할 경우 4.9E-324 ~ 1.8E308, 오차 없는 범위는 15자리이다.
double은 8byte로 부호(Sign bit) 1개, 지수 11개, 가수 52개로 구성되어 있다. 정밀도로 인해 실수에서 double은 default이다.

---

🍘 #ch2-12~13장, printf를 이용한 출력

PrintEx.java 참고

println()의 단점 
: 출력형식 지정불가

실수의 자리수 조절불가하며 10진수로만 출력이 되는 단점이 있다.
소수점 n자리수를 지정해 출력하거나 8진수, 16진수를 출력하려면 printf() 를 사용하여야 한다.

printf() method는 지시자(specifier)를 통해 선택해 원하는 출력이 가능하다. 지시자의 구성의 갯수에는 한계가 없고 원하는 만큼 표현할 수 있다.

🍘 printf()의 지시자(specifier)를 참고할 Java API

: Class Formatter를 참고하면 지시자(specifier)에 대한 내용을 자세히 알아볼 수 있다.

🍘 printf()의 자주 쓰이는 지시자(specifier) 형식. 

%b : Boolean 형식으로 출력

🍘 "%s", Interger.toBinaryString(숫자) : Integer.toBinaryString()는 값을 2진수로 출력

%d : 10진수(decimal) 정수의 형식

%o : 8진수(octal) 정수의 형식

%#o : 8진수(octal) 정수에 접미사 추가해 출력

%x : 16진수(hexa-decimal) 정수의 형식

%#x : 16진수(hexa-decimal) 정수에 접미사 추가해 출력

%f : 부동소수점(floating-point)의 형식

%e : 지수(exponent) 표현식의 형식

%g : 실수를 간략한 형식으로 출력. 기본적으로 글자 7자리만 출력

%c : 문자(character)로 출력

%s : 문자열(String)로 출력

%n : 개행문자(줄바꿈) 실행

[ ] : 중괄호

% 다음에 정수는 전체 자리수를 결정하는 수이고, 소수점 뒤에 숫자를 표기할 경우 소수점 n번째 자리까지 표현하라는 의미이다.

또한 % 뒤에 '-' 부호를 넣을 경우 정렬을 반대로 정렬한다. 기본 정렬은 우측정렬이며 '-' 부호를 작성할 경우 왼쪽정렬로 출력한다.

% 뒤에 숫자 0을 붙일 경우, 전체자리 중 빈자리에는 숫자 0으로 채운다.

---

🍘 #ch02-14, 화면으로부터 입력받기

ScanfEx1.java 참고

Scanner란?
: 화면으로부터 데이터를 입력받는 기능을 제공하는 Class

🍘 Scanner를 사용하려면?

import문 추가
: 자세한 내용은 7장을 참고한다.

Scanner객체의 생성
: 자세한 내용은 6장을 참고한다.

Scanner객체를 사용
: int num = scanner.nextInt();

🍘 Scanner 입력관련 method()
scanner.nextInt()는 정수를 입력받는다.
scanner.nextFloat()는 실수를 입력받는다.
scanner.nextLine()는 한 행단위로 입력받는다.

🍘 문자열을 정수, 실수로 변환
Integer.parseInt(문자열);은 문자열을 정수로 바꾼다.
Double.parseDouble(문자열);은 문자열을 실수로 바꾼다.

🍘 숫자를 문자열로 변환
숫자 + "";는 숫자를 문자열로 바꾼다.

---

🍘 #ch02-15~16, 정수형의 오버플로우(Overflow, 넘치다)

실습

Ex2_11.java 참고

10진수를 예를 들면, 계수기(Counter)처럼 최대값인 9999 다음 10000이 아닌 다시 0000, 0001, 0002, ... 과 같이 정해진 숫자 안에서 다시 초기화되어 0부터 시작하는 것을 Overflow라고 한다.

2진수도 마찬가지로 4개의 bit로 구성될 때 최대값인 1111 다음 10000이 아닌 다시 0000, 0001, 0010, ... 과 같이 다시 초기화되어 0부터 시작되는 것을 Overflow라고 한다.

결국, 최대값 + 1은 최소값으로 돌아가며 최소값-1은 최대값으로 돌아간다.
Overflow원리는 TV의 채널을 올리고 내리는 것과 유사하다.

🍘 부호없는 정수와 부호있는 정수, 4bit의 경우

: 부호없는 정수인 4bit의 표현범위는 0(최소값) ~ 15(최대값)

15 + 1 = 0
0-1 = 15

: 부호있는 정수인 4bit의 표현범위는 -8(최소값) ~ 7(최대값)이다.

7 + 1 = 8
8-1 = 7

부호없는 정수는 2진수로 '0000'이 될 때 Overflow가 발생하고 
부호있는 정수는 부호비트(Sign bit)가 0 (7은 0111)에서 1(-8은 1000)이 될 때 Overflow가 발생한다.

---

🍘 #ch02-17 타입간의 변환방법

실습

Ex2_12.java를 참고.

🍘 문자와 숫자간의 변환

숫자 + '0' = 문자
문자-'0' = 숫자

문자 '0'을 더하거나 빼면 문자와 숫자로 변환할 수 있다.

🍘 문자열로의 변환

숫자 + "" = 문자열
문자 + "" = 문자열

숫자와 문자에 빈 문자열을 더해주면 문자열로 바꿀 수 있다.

🍘 문자열을 숫자로 변환

Integer.parseInt(문자열로 된 숫자)로 문자열 "3"을 숫자 3으로 바꿀 수 있다.

Double.parseDouble(문자열로 된 실수)로 문자열을 실수로 바꿀 수 있다.

charAt(0)로는 문자열을 문자로 바꿀 수 있다. 예를 들면 변수 Literal.charAt(0) 혹은 "3".charAt(0)으로 '3'으로 바꿀 수 있다.



---


🍘 #ch03-1~2, 연산자와 피연산자

Coding memo ( Java ).txt와 묶어 내용 정리할 때 다시 정리할 것.

연산자
: 연산을 수행하는 기호. + ,-, * , / 을 일컫는다. 모든 연산자는 연산결과를 반환한다.

피연산자
: 연산자의 연산 수행 대상이다.

식(expression)인 x + 3에서 연산자는 + 이고, x와 3은 피연산자이다.

🍘 연산자의 종류

🍘 산술연산자 ( 사칙연산과 나머지 연산(%) )
: +-* / % << >>

🍘 비교연산자 ( 크고 작음과 같고 다름을 비교 )
: > < >= <= == !=

🍘 논리연산자 ( AND, OR, NOT 등과 비트연산자(bit operator) 포함 )
: && || ! & | ^ ~

🍘 비트 연산자 ( bit operator )
a & b
: AND 연산. 두 bit가 모두 1이면 1, 아니면 0

a | b
: OR 연산. 두 bit가 모두 0이면 0, 아니면 1

a ^ b
: XOR 연산. 두 bit가 다르면 1, 같으면 0

~ a
: NOT 연산. 1을 0으로, 0을 1로 변환

🍘 비트 연산 활용 사례

byte flag; 
: 8개의 각 bit는 8개의 냉장고 센서(true, false) 값을 가리킨다고 하자.

( flag & 0b00001000 == 0) ? System.out.print("온도는 0도 이하"); : System.out.print("온도는 0도 이상");
: 온도는 0도 이상
만약, bit 3번째 센서 값이 0이면 "온도는 0도 이하"가 되니 온도 측정하는 곳에서 활용되는 사례의 예이다.

🍘 대입연산자
: =
우변의 값을 좌변에 저장

🍘 기타 
: (type) ?: instanceof. 형변환 연산자, 삼항연산자, instanceof연산자

(type) : 형변환을 의미하며
?: 는 삼항연산자라는 조건문을 뜻한다. 조건연산자.
instanceof : 객체지향에서 쓰인다.

---

🍘 #ch03-3~4, 연산자의 우선순위와 결합규칙

🍘 연산자의 우선순위
: 하나의 식(expression)에 연산자가 둘 이상 있을 때, 어떤 연산을 먼저 수행할지를 자동 결정하는 것. ( )에 경우 수동으로 먼저 수행한다.

단항연산자인 양수, 음수를 표현하는 +,-연산자가 이항 연산자인 +-* /인 사칙연산보다 우선순위가 높다.
곱셈과 나눗셈이 덧셈보다 우선순위가 높다.
산술연산자가 비교연산자보다 우선순위가 높다.
비교연산자가 논리연산자보다 우선순위가 높다
대입연산자는 우선순위가 가장 낮다.

산술 > 비교 > 논리 > 대입순으로 우선순위가 높고 낮다.
단항(피연산자가 1개) > 이항(산술) > 삼항(조건)로 우선순위가 높고 낮다.

🍘 연산자의 결합규칙

대입( = )연산자와 단항(+ -로 양수, 음수인 부호 표현)연산자를 제외하고는 왼쪽에서 오른쪽으로 연산하며, 대입과 단항연산은 우측에서 왼쪽으로 연산한다.

---

🍘 #ch03-5~6, 증감연산자, 부호연산자( 단항연산자 )

실습

Ex3_2.java를 참고
Ex3_4.java를 참고

🍘 증감 연산자

증가연산자(++) 
: 피연산자의 값을 1 증가시킨다.

감소연산자(--)
: 피연산자의 값을 1 감소시킨다.

상수(final)은 값을 변경할 수 없으므로 증감연산자가 쓰이지 못한다.

🍘 전위형과 후위형
: 식을 간소화하기 위해 만들어졌다.

🍘 전위형, j = ++i;
: 값이 참조되기 전에 1 증가시킨다.

풀어보면 
++i; 
j = i;

와 같다.

🍘 후위형, j = i++;
: 값이 참조되고 난 후에 1 증가시킨다.

풀어보면
j = i;
i++; // 독립적으로 사용될 경우 ++i; 와 차이가 없다

와 같다.

독립적으로 사용된 ++i; 와 i++;의 차이는 없다. 

🍘 부호연산자

'-'는 피연산자의 부호를 반대로 변경( 단항연산자이기도 하다 )
' + '는 Java에서는 아무런 일도 하지 않는다. 실제로 사용되지 않는다고 보는 것이 바람직하다.

부호연산자는 boolean형과 char형을 제외한 기본형에만 사용할 수 있다.

---

🍘 #ch3-7~8, 형변환 연산자, 자동 형변환

🍘 형변환이란?
: 연산을 수행하기 전에 타입을 일치 시켜야 하는데, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것

'(타입)피연산자' 의 구조로 작성한다.

double d = 85.4;
int score = (int)d;

(int)d; 처럼 앞에 타입을 적어야 한다. 변수 d의 값은 변하지 않고 읽어온 값으로만 변환한다.

🍘 형변환 연산자

: 유니코드에서 문자에 따른 숫자를 변수에 저장한다. 실제로는 10진수가 아닌 2진수의 값을 변수에 저장한다.

int --> char로 형변환 시 (char)65에 경우, 결과는 'A'가 된다.
float --> int로 형변환 시 (int)1.6f에 경우, 결과는 '1'이 된다. 소수점은 반올림이 되지 않는다.
int --> float로 형변환 시 (float)10에 경우, 결과는 '10.0f'가 된다.

🍘 유니코드에 따른 간단 표, 일명 암호표

문자 0~9는 숫자 48~57, 문자 A~Z는 숫자 65~90, 문자 a~z는 97~122으로 기록되어 있다. 
이를 참고하여 Computer는 변수에 저장된 숫자를 읽고 문자를 표현한다.

참고로, 유니코드는 6만자로 출시했다가 한자로 인한 수량부족으로 현재는 100만자까지 표기할 수 있게 바뀌었다.

🍘 자동 형변환

float f = 1234; 처럼 형변환을 생략하면 사실 Compile하는 과정 중에 아래처럼 바꾼다.
float f = (float)1234; 이처럼 바꿔주는 것을 자동 형변환이라고 한다.

타입은 작은 것이 큰 것으로 변환할 때 자동으로 형변환하여 준다.

int i = 3.14f;
: 이 경우에는, 에러가 발생한다. 3.14f에서 .14f는 값손실이 발생하며 int i = (int)3.14f;로 바꾸어야 한다.

실제로는 형변환은 자동으로 이루워지나, Compiler가 값손실이 예상될 경우 수동으로 타입을 지정하게 권한다.
만약, int --> byte로 형변환 시 1byte를 제외한 나머지 메모리 공간이 사라지기 때문에 '300'은 값손실로 '44'가 된다.

🍘 자동 형변환 가능 표

byte --> short --> int --> long --> float --> double

char는 표현하는 양이 다르기 때문에 short가 아닌 int로 자동 형변환이 가능하다.
long은 E19(10의 19승)이고 float는 E38(10의 38승)이므로 float가 더 크다.

byte b = 100; 인 경우 '100'이 int 타입이지만, 값이 byte보다 작기 때문에 Compiler가 자동으로 변환해준다.
byte i = b;인 경우, Literal이 '100'이라는 것이 알지만, Compiler는 b를 읽어올 때는 크기를 알 수 없어 (int) b; 로 표기해야 한다.


---

🍘 #ch3-9~10, 사칙 연산자, 산술변환

실습
Ex3_6.java 참고
Ex3_9.java 참고

사칙 연산자 +-* /
: +는 덧셈, -는 뺄셈, *는 곱하기, /는 나누기로 기본 4칙 연산할 때 필요한 수식이다.

🍘 산술변환

: 연산 전에 피연산자의 타입을 일치시키는 것

🍘 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)

: 서로 다른 type은 자료형(primitive)의 범위가 넓은 것으로 자동 형변환이 이뤄진 후 연산한다. 연산 결과는 변환된 type을 따른다.

long + int --> long + long --> long
float + int --> float + float --> float 
double + float --> double + double --> double

🍘 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.

byte + short --> int + int --> int
char + short --> int + int --> int

byte는 -128~127, char는 0~6만, short는 -3만 ~ 3만의 범위이지만 계산범위가 작기 때문에 Overflow로 인해 int로 형변환을 하고 계산을 한다.

'2'-'0' --> 50-48 --> 2

char는 int로 자동 형변환이 이뤄지는데 '2'와 '0'의 유니코드의 의한 값은 50과 48이다. 따라서 결과는 int type의 숫자 2가 된다.

---

🍘 #ch3-11~12, 반올림 Math.round(), 나머지 연산자

실습
Ex3_11.java 참고
Ex3_12.java 참고

🍘 반올림 Math.round()

: 실수를 소수점 첫 째자리에서 반올림한 정수를 반환

long result = Math.round(4.52); 일때 result는 결과가 5이다.

🍘 나머지 연산자 %

: 오른쪽 피연산자로 나누고 남은 나머지를 반환. 나누는 피연산자는 0이 아닌 정수만 허용(부호(Sign type)은 무시됨)
음수 부호를 앞선 나누어햘 할 수에 붙이거나 두 수를 음수 부호를 넣고 나눌 경우 결과값이 음수가 된다.

---

🍘 #ch3-13~14, 비교 연산자, 문자열의 비교

비교연산자 > < >= <= == !=
: 두 피연산자를 비교해서 True(참)과 False(거짓)을 반환

비교연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이 서로 다를 경우에는 
자료형의 범위가 큰 쪽으로 자동 형변환하여 타입을 일치시킨 후에 비교한다.


🍘 대소비교 연산자
> 
: 좌변 값이 크면, true 아니면 false

<
: 좌변 값이 작으면, true 아니면 false

>=
: 좌변 값이 크거나 같으면, true 아니면 false

<=
: 좌변 값이 작거나 같으면, true 아니면 false

단, =>와 =< 혹은 사이에 공백이 들어갈 경우에는 사용될 수 없다. 항상 좌변을 기준으로 한 대소비교만을 전재로 한다.

만약, 'A' > 'B' 를 비교할 경우, char type이 int type으로 변환되어 65 > 66으로 대소비교를 하게되어 false 값을 결과로 얻는다.

🍘 등가비교 연산자
==
: 두 값이 같으면, true 아니면 false

!=
: 두 값이 다르면, true 아니면 false

기본형과 참조형 변수에 경우에는 서로 형변환이 가능하지 않기 때문에 기본형과 참조형을 비교할 수는 없다.

🍘 문자열 비교

: 문자열 비교에는 == 대신 equals() method를 사용해야 한다.

예를 들어, 

String str1 = "abc";
String str2 = "abc";
System.out.println(str1==str2); // true
System.out.println(str1.equals(str2)); // true

결과값 두개는 서로 같은 값이 나온다. 그러나 new 연산자를 이용해 생성할 경우 ==의 결과는 false로 다르게 나온다. 이 차이는 9장에서 배우게 된다.

String str1 = new String("abc");
String str2 = new String("abc");
System.out.println(str1==str2); // false
System.out.println(str1.equals(str2)); // true

이러한 이유로 equals() method를 사용해야 한다.

---

🍘 #ch3-15~16, 논리 연산자, 논리 부정연산자

🍘 논리연산자 && ||
: 조건식을 연결할 때 사용하는 연산자

|| (OR결합)
: 피연산자 중 어느 한 쪽이 true이면 true를 결과로 얻는다.

&& (AND결합)
: 피연산자 양쪽 모두 ture이어야 true를 결과로 얻는다.

🍘 x는 10보다 크고, 20보다 작다. 일때

: x > 10 && x < 20 으로 표현하며, 10 < x && x < 20으로 가독성을 높여 표현하는 것이 보다 나을 수도 있다.

🍘 i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다. 일때

: ( i%2==0 || i%3==0 ) && i%6 != 0

🍘 문자 ch는 숫자( '0' ~ '9' )이다.

: '0' <= ch && ch <= '9'

🍘 문자 ch는 대문자 또는 소문자이다.

: ( 'a' <= ch && ch <= 'z' ) || ( 'A' <= ch && ch <= 'Z' )

🍘 논리 부정 연산자 !

: true를 false로, false는 true로 바꾼다. 주로 사용되는 곳은 조건문과 반복문의 조건식이다.

🍘 !!true

boolean b = true;
!!b 일 경우
!!b --> !!true --> !false --> true 로 되돌아온다.

이 같은 원리는 토글 버튼(toggle button)과 유사하다.

🍘 문자 ch가 소문자가 아니다. 일때

ch < 'a' || ch > 'z' 보다는 !( 'a' <= ch && ch <= 'z' )로 적는 것이 더 직관적이다.


---

🍘 #ch3-17~19, 조건 연산자, 대입 연산자

조건 연산자 ? :

: 조건식의 결과에 따라 연산결과를 달리한다.

🍘 result = ( x > y ) ? x : y ;

: result = (조건식) ? 식1 : 식2; 인 구조를 가지고 조건식이 true이면 식1이, false이면 식2가 result로 대입된다.

조건식을 괄호로 묶지만 가독성을 위한 것이며 필수는 아니다.

if문과 같다.

🍘 대입 연산자

: 오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환. 예를 들면 아래와 같다.

System.out.println( x = 3 );
System.out.println( 3 );

🍘 lvalue, rvalue

x = 3
: x는 lvalue( left value )라 하고 값을 저장할 공간을 지칭하며, 3은 rvalue( right value )라고 하며 Literal을 가리킨다.

🍘 대입연산자에서의 Error
int i = 0;

3 = i + 3;
i + 3 = i;

: lvalue가 값을 저장할 공간이 아니다.

final int MAX = 3;
MAX = 10;

: 상수는 값을 한번 저장하면 변경할 수 없다.

🍘 복합 대입연산자

: 대입 연산자와 다른 연산자를 하나로 축약

i += 3; 
: i = i + 3;

i -= 3;
: i = i-3;

i *= 3;
: i = i * 3;

i /= 3;
: i = i / 3;

i %= 3;
: i = i % 3;

i <<= 3;
: i = i << 3;

i >>= 3;
: i = i >> 3;

i &= 3;
: i = i & 3;

i ^= 3;
: i = i ^ 3;

i |= 3;
: i = i | 3;

i *= ( 10+j );
: i = i * ( 10 + j );

---

🍘 #ch4-1~4, 조건문if문과 if-else문

Ex4_1.java
Ex4_2.java
Ex4_3.java

🍘 조건문 

: 조건을 만족할때에만 { }를 수행(0~1번), if문과 switch문이 있다.

🍘 반복문

: 조건을 만족하는 동안 { }를 수행(0~n번), for문과 while문이 있다.

조건문과 반복문을 제어문( Flow control statements )이라고 한다.

🍘 if문

: 조건식이 참(true)일 때, 중괄호 { } 안에 작업문들을 수행한다.

if (조건식) {
    // 조건식이 참(true)일 때 수행될 문장들을 적는다.
}

조건식에는 true, false만이 올 수 있으며 다른 연산인 경우 에러가 발생한다.

만약, 등가비교 연산자 '==' 대신 대입연산자 '='를 사용할 경우 if (x=0) { ... } 는 if (0) { ... }이 되며 결과가 true 혹 false가 아니라서 에러가 발생한다.

🍘 조건식의 다양한 예,

90 <= x && x <= 100
: 정수 x가 90이상 100이하일때 

x < 0 || x > 100
: 정수 x가 0보다 작거나 100보다 클 때

x%3==0 && x%2!=0
: 정수 x가 3의 배수지만, 2의 배수는 아닐 때

ch == 'y' || ch == 'Y'
: 문자 ch가 'y' 또는 'Y' 일때

ch==' ' || ch=='\t' || ch=='\n'
: 문자 ch가 공백이거나 탭 또는 개행 문자일 때

'A' <= ch && ch <= 'Z'
: 문자 ch가 대문자일 때

'a' <= ch && ch <= 'z'
: 문자 ch가 소문자일 때

'0' <= ch && ch <= '9'
: 문자 ch가 숫자일 때

str.equals("yes")
: 문자열 str의 내용이 "yes"일 때 ( 대소문자 구분 ). 만약 Yes인 경우에는 false로 된다.

str.equalsIgnoreCase("yes")
: 문자열 str의 내용이 "yes"일 때 ( 대소문자 구분 안함 ). 만약 Yes인 경우에라도 true가 된다.

문자열 비교일 때는 '=='를 사용해서는 안 된다.

🍘 블럭(block) { }

: 중괄호( curly bracket )를 블럭이라고 하며, 여러 문장을 하나로 묶어주는 데에 쓰인다. 안에 내용은 들여쓰기(indentation)를 하여 구분해 준다.

C/C++나 Java에서는 작업문이 하나일 경우에는 블럭 { }을 생략할 수 있다.

🍘 if-else 문

: 둘 중의 하나의 조건식이 참일 때와 거짓일 때로 나눠서 처리

if (조건식) {
    // 조건식이 참(true)일 때 수행될 문장들을 적는다.
} else {
    // 조건식이 거짓(false)일 때 수행될 문장들을 적는다.
}

---

🍘 #ch4-5~8, if-else if문과 중첩 if문

실습 중점
Ex4_4.java
Ex4_5.java

🍘 if-else if문

여러 개 중의 하나가 참 일 때 처리. 여러 개의 조건식을 포함한 조건식

if (조건식1) {
    // 조건식1의 연산결과가 참일 때, 수행될 문장들을 적는다.

} else if (조건식2) {
    // 조건식2의 연산결과가 참일 때, 수행될 문장들을 적는다.

} else if (조건식3) {
    // 조건식3의 연산결과가 참일 때, 수행될 문장들을 적는다.

} else {
    // 마지막은 else Block으로 끝나며, else Block은 생략할 수 있고 위의 어느 조건식도 만족하지 않을 때 수행될 문장들을 적는다.
}

refactoring 과정에서 else는 생략할 수 있다면 생략하는 것이 좋다. 

🍘 중첩 if문, if문 안의 if문

if (조건식1) {
	// 조건식1의 연산결과가 true일 때 수행될 문장들을 적는다.
	
	if (조건식2) {
		// 조건식1과 조건식2가 모두 true일 때 수행될 문장들
	} else {
		// 조건식1이 true이고, 조건식2가 false일 때 수행될 문장들
	}
} else {
	// 조건식1이 false일 때 수행될 문장들
}

: 중첩횟수는 제약이 없다. 

---

🍘 #ch4-9~11, switch문

Ex4_6.java

🍘 switch문

처리해야 하는 경우의 수가 많을 때 사용하는 조건문, if else문과 switch문을 주로 쓴다.

switch (조건식) {
	case 값1 :
		// 조건식의 결과가 값1과 같을 경우 수행될 문장들
		// ...
		break;
	case 값2 :
		// 조건식의 결과가 값2와 같을 경우 수행될 문장들
		// ...
		break;
	// ...
	default :
		// 조건식의 결과와 일치하는 case문이 없을 때 수행될 문장들
		// ...
}

: default문은 switch문은 제일 마지막에 오면 벗어나는 조건문이므로 break; 를 생략할 수 있고, default문 또한 생략할 수 있다.
그러나 그외 작업문에서 break; 가 없는 경우 다음 작업문에 break; 까지 수행하므로 실수로 break;를 생략하지 않도록 주의해야 한다.

: if문의 조건식에서는 true, false로만 계산하지만 switch문의 조건식은 정수와 문자열만 올 수 있다. switch문은 제약조건이 있다.
이 때문에 if문에서 switch문으로 변환할 수 없는 경우가 있어 if문을 쓰는 경우도 있다.

🍘 switch문의 제약조건

1. switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
: 단, JDK 1.7 이후에만 문자열도 허용되지만 실무에서는 JDK 1.7보다 낮은 버전을 사용하기도 한다.

2. case문의 값은 정수, 상수(문자 포함), 문자열만 가능하며, 중복되지 않아야 한다.
: 따라서 변수, 실수는 사용할 수 없다. 상수의 경우에는 초기화한 변수로 고정된 값을 제공하므로 사용할 수 있다.

---

🍘 #ch4-12, 임의의 정수 만들기

Ex4_7.java

임의의 정수
: 난수라고 하며, 어지러울 난(亂)을 사용한다. 게임이나 뒤섞고자할 때 사용한다.

🍘 Math.random()
: 0.0과 1.0 사이의 임의의 double값을 반환

0.0 <= Math.random() < 1.0
: 0.0 ~ 0.9999... 까지 포함되며, 1.0은 포함되지 않는다.

예를 들어, 1~3 사이의 정수를 구하고자 원한다면,

1. 각 변에 3을 곱한다.
: 0.0 <= Math.random() * 3 < 3.0

2. 각 변을 int형으로 변환한다.
: 0 <= (int)(Math.random() * 3) < 3 
즉, 0~2의 범위를 갖는다.

3. 각 변에 1을 더한다.
: 1 <= (int)(Math.random() * 3) + 1 < 4
즉, 1~3의 범위를 갖는다.

---

🍘 #ch4-13~14, for문

실습
Ex4_8.java
Ex4_9.java
Ex4_10.java

🍘 for문

조건을 만족하는 동안 Block { }을 반복, 반복횟수를 알 때 주로 쓰인다.

반복문에는 for문, while문, do-while문이 있다. 조건문에는 if문, if-else문, switch문이 있다.

for (초기화; 조건식; 증감식) { 
    수행될 문장
}

으로 구성되어 있다. 조건식이 false가 나올 때에는 for문을 벗어난다.

🍘 초기화, 증감식
: 여러 변수 초기화할 경우에는 type이 같아야 한다. 증감식에서는 여러 변수를 증감시킬 수 있다.
for문 안에서 변수를 초기화할 경우에는 for문 안에서만 쓰이는 field(멤버 변수, local variable(지역변수)라고도 불린다)가 된다. 
main() 안에 field(멤버 변수)로 선언하면 main() method안에 for문 밖에서도 쓰일 수 있다.

🍘 조건식
: 1 >= 1, for( ; true; ) 혹 for ( ; ; )로 비어있는 경우에는 무한반복(infinite loop)가 되니 주의해야 한다.

---

🍘 #ch4-15, 중첩 for문

Ex4_11.java

🍘 중첩 for문

: for문 안에 for문을 작성함으로써 연산을 수월하게 하는 방법 중 하나이다. 2중 for문을 주로 쓰고, 3중 이상은 주로 쓰지 않는다.

구구단, 별(*) 찍기 등 만들면서 연습하면 2중 for문에 대해 이해하기 수월하다.

---

🍘 #ch4-16~19 while문, do-while문

Ex4_12.java
Ex4_13.java
Ex4_14.java
Ex4_15.java

🍘 while문
: 조건을 만족시키는 동안 Block { }을 반복, 주로 반복횟수를 모를 때 사용한다. 

for문과는 달리 반복횟수에 대해 모를 때 while문을 사용한다. for문과 while문은 서로 바꿀 수 있다.

while (조건식) {
    // 조건식의 연산결과가 참(true)인 동안, 반복될 문장들을 적는다. 조건식이 거짓(false)가 되면 while문의 반복은 끝이 난다.
}

🍘 for문을 while문으로 바꿀 경우

초기화;

while (조건식) {
    // 조건식의 연산결과가 참(true)일 때, 반복될 문장들을 적는다.
    증감식;
}

으로 작성해야 한다.

🍘 do-while문

: while문과는 다르게 block { }을 최소한 한 번이상은 실행해 반복하며, 사용자 입력을 받을 때 유용하다.

do {
    // 조건식의 연산결과가 참(true)일 때 수행될 문장들을 적는다. ( 처음 한번은 무조건 실행 )
} while (조건식); 

끝에 세미콜론( ; )은 필히 작성할 것.

while문으로 작성 시 입력받는 코드를 2번 이상 작성해야 하는 번거로움이 있을 때, do-while문으로 작성하면 입력받는 코드를 1번만 작성하면 된다.

---

🍘 #ch4-20~24 break문, continue문, 이름붙은 반복문

Ex4_16.java
Ex4_17.java
Ex4_18.java
Ex4_19.java
Ex4_20.java

🍘 break문

: switch문, while문에서 자신이 포함된 하나의 반복문을 벗어날 때 사용된다. 

🍘 무한반복(infinite loop)
: while (true) { ... } 와 for ( ; ; ) 등은 무한반복이 되는 반복문이다. while문에서는 조건식이 생략되면 에러가 발생한다. 
이 무한반복을 벗어나기 위해 break문을 사용한다.

🍘 continue문

: 자신이 포함된 반복문의 끝으로 이동, 다음 반복으로 건너뛴다. 

🍘 이름붙은 반복문

: 반복문에다 이름을 붙여서 하나 이상의 반복문에서 벗어날 수 있다. 기본적으로 break; 문은 자신이 포함된 하나의 반복문만을 벗어난다.

반복문 앞에다 이름을 적고 콜론 ( : )으로 마무리한다. 

name : for ( ... ) { ... } 로 적고 break name; 혹은 continue name;으로 해당 for문까지 벗어나거나 건너뛸 수 있다. 

--- 

🍘 #ch5-1~3, 배열의 생성과 선언, 배열의 인덱스

🍘 배열
: 배열은 같은 타입(Type)의 여러 변수를 하나의 묶음으로 다루는 것. 
배열은 각 공간의 번호는 0~n으로 시작하며 이를 index라 부른다. 참조할 변수(reference variable)에 [ ]를 붙여 배열을 선언하여 나타내고 
[ ] 안에 index의 값( 0 ~ n )에 따른 할당된 공간을 element라 부르며 해당 reference variable의 이름을 따서 variable[0] ~ variable[n]으로 나타낸다.

배열의 타입은 같고 연속성을 가진다.

🍘 배열의 선언과 생성

🍘 배열의 선언
: 배열을 다루기 위한 참조변수(reference variable)의 선언이다.

타입[ ] 변수이름;
타입 변수이름[ ]

로 2가지 방법이 있으며, 전자가 Java에서 주로 권하는 방법이며 후자는 C언어에서 쓰이는 방법이다.


🍘 배열의 생성
: 실제 저장공간을 할당받아 생성한다.

변수이름 = new 타입[길이]

로 작성한다.

: 위의 방법과 달리 선언과 생성을 동시에 할 수 있다.

타입[ ] 변수이름 = new 타입[길이] 로 작성하면 된다.

🍘 배열의 index

: 각 element에 자동으로 붙는 번호이며, index의 범위는 0부터 '배열길이-1'까지이다. 할당된 공간을 배열의 요소(element)라 한다.

변수이름[0] ... 변수이름[n] 와 같이 [ ]안에 index를 나타내 element를 가리킬 수 있다.

---

🍘 #ch5-4~5, 배열의 길이, 배열의 초기화

Ex5_1_tmp.java

🍘 배열의 길이
: 배열의 길이는 int형인 상수를 가지며 아래와 같이 작성하여 배열의 길이값을 호출한다. 주로 조건식에 배열의 길이를 담을 때 쓰인다.

' 배열이름.length '로 작성한다.

그러나 배열은 한번 생성한 뒤 실행 중에는 그 길이를 바꿀 수 없다. 
배열의 수를 도중 늘리고 싶을 때 메모리 공간이 'int ( 4byte ) x 배열의 할당된 수'만큼 
새로 메모리 공간을 만든 후 기존 값을 복사하는 과정이 있기 때문에 배열 생성 후에 실행 중에는 배열의 길이를 변경할 수 없다.

🍘 배열의 초기화
: 배열의 각 element에 처음으로 값을 저장해 놓는 것. 기본적으로 초기화하지 않을 경우 int Type으로 0으로 저장된다. 작성방법은 아래와 같다.

타입[ ] 변수이름 = new 타입[ ] { 값, 값, ... 값 };
타입[ ] 변수이름 = { 값, 값, ... 값 }; 

로 작성하며 new 타입[ ]은 생략하는 방법으로 주로 쓰인다, 
배열의 선언과 초기화를 나누어야 되는 경우에는 new 타입[ ]을 추가하지 않으면 에러가 발생한다.

---

🍘 #ch5-6~7, 배열의 출력

Ex5_1_tmp.java
Ex5_1.java

System.out.println(배열이름)
: [I@1c4af82c 에서 ' [ '는 배열을 나타내고 ' I '는 int Type을 나타내며 @ 뒤에 값은 메모리가 저장된 위치를 나타낸다. 9장에서 자세히 설명한다. 

그러나 char[ ] Type에 경우에는 배열의 값을 그대로 출력해준다.

따라서 for문을 통해 배열[증감될 변수]로 하나씩 작성하여 출력하는 방법을 쓰지만 아래와 같이 쉽게 출력하는 방법을 주로 쓴다.

Arrays.toString(배열이름)
: 배열의 값을 문자열로 바꾸어 불러온다. System.out.println( ~ )에 작성 시 배열의 값을 쉽게 불러올 수 있다.

---

🍘 #ch5-8~11, 배열의 활용 (1) ~ (4)

Ex5_2.java
Ex5_3.java
Ex5_4.java
Ex5_5.java

🍘 배열의 활용

총합과 평균
: 평균을 구할 때에는 평균은 float 혹 double type으로 선언하며 배열의 길이인 갯수로 나눌 때에 float로 형 변환하여야 정확한 결과를 얻는다.

최대값과 최소값
: 최대값과 최소값의 변수 2개를 만들어 for문과 if문을 통해 배열에 하나씩 검증하며 찾는다.

섞기(shuffle)
: ch2-9, 두 변수의 값 바꾸기 강의를 참고하여 난수로 쓰일 변수를 통해 index 범위를 임의로 지정하여 두 변수의 값을 바꾼다.

로또 번호 만들기
: 1~45개 공을 생성, 초기화한 후 섞을 때 쓰일 임시변수, 난수로 쓰일 변수를 갖고 for문을 통해 6번 섞고 난 뒤 index가 0~5인 로또배열을 순서대로 출력

---

🍘 #ch5-12~13, String 배열

Ex5_6.java
Ex5_6_tmp.java

🍘 String배열의 선언과 생성

String[ ] 배열이름 = new String[할당될 공간의 수];

: String은 기본적으로 타입이 참조형인 Class이다.

🍘 String배열의 초기화

String[ ] 배열이름 = new String[ ] { "값1", "값2", ... };

String[ ] 배열이름 = { "값1", "값2", ... };

: new String[ ]은 생략할 수 있다.


변수[index 번호] = "값";

: String Class에서만 위와 같이 "값"으로 객체를 저장할 수 있지만, 원래는 아래처럼 new 연산자를 통해 객체를 생성하여야 한다.

변수[index 번호] = new String("값");

으로 객체를 생성해 값을 초기화하여야 한다.


: 실제로 배열에 값을 저장하는 것이 아닌 참조할 주소만을 저장하는 것이고 값은 이 참조할 주소( 0x100 같은 Memory 주소 ) 안에 저장된다.


🍘 변수의 타입에 따른 기본값

: default값은 참조형은 null이고 나머지는 0 혹은 false를 갖는다.

boolean
: false

char
: '\u0000'

byte, short, int
: 0

long
: 0L

float
: 0.0f

double
: 0.0d 또는 0.0

참조형
: null

---

🍘 #ch5-14~15, String 클래스

ch5_6_tmp2.java

🍘 String Class

: String Class는 char 배열과 method( 기능, function과 뜻이 일맥상통 )를 결합한 것

객체지향언어(OOL, Object oriented language)에서는 데이터와 그에 관련된 기능을 하나의 Class에 묶어서 다룰 수 있게 한다.
여기서 데이터는 기본형(primitive type), 참조형(reference type)을 가리키고 기능은 함수(function)를 뜻하며 OOL에서는 Method라고 부른다.

🍘 String Class는 내용을 변경할 수 없다. ( read only )

: 새로운 값을 기존 reference에 저장할 경우에는 새로운 reference를 생성해 기존에 참조했던 주소가 아닌 새로운 주소를 가리키게 된다. 
따라서 내용을 변경하는 것 같지만 새로운 값을 참조할 주소를 새로 받는 것이다.  이 내용은 '9장, java.lang 패키지와 유용한 클래스'를 참고

🍘 String Class의 주요 Method( )

char charAt(int index)
: 문자열에서 해당 위치(index)에 있는 문자를 반환. 배열에서 '배열이름[index]'로 값을 가져오는 것과 같다.

int length( )
: 문자열의 길이를 반환

String substring(int from, int to)
: 문자열에서 해당 범위(from ~ to)의 문자열을 반환하며 마지막 to에 대한 범위는 포함되지 않는다.
마지막 to의 범위를 생략할 경우 from부터 문자열 끝까지 반환하며, 이는 '배열.length'로 준 것과 같다.

boolean equals(Object obj)
: 문자열의 내용이 같은지 확인한다. 같으면 결과는 true, 다르면 false이다. 또한 대소문자를 구분한다.

boolean equalsIgnoreCase( )
: equals( )와는 다르게 대소문자를 구분하지 않고 문자열의 내용이 같은지 확인한다.

char[ ] toCharArray( )
: 문자열(String)을 문자배열(Char [ ])로 변환해서 반환한다. 

---

🍘 #ch5-16~17, Command line 입력받기

Ex5_7.java

🍘 cmd에서 입력받기

: cmd에서 입력한 값(Argument)이 문자열 배열에 담겨서 전달된다. 

Eclipse -> Alt + Enter 에서 나온 경로에서 src가 아닌 bin에는 *.class 파일들이 모여 있다. cmd에서 이 경로로 가서 java Ex5_7 문자열1 문자열2 "문자열3 문자열4" 와 같이 Argument와 같이 실행하면 된다.

class 파일명 뒤에 Argument(인수)는 공백으로 구분하며 " "로 사이에 공백은 구분되지 않고 문자열 배열에 담겨져 전달된다.

만약, cmd의 type 명령으로 .class 파일 내용을 보고 싶다면 .java가 있는 src 경로로 이동하여 볼 수 있다.


🍘 Eclipse에서 입력받기

: Eclipse에서는 Run -> Run Configurations -> Arguments에서 값을 넣어 main( )로 보낼 수 있다.

공백으로 Argument(인수)를 구분하며 " "로 작성된 값에 공백은 구분되지 않고 문자열 배열에 담겨져 전달된다.

🍘 매개변수(parameter)의 개수

: ""와 같은 빈 문자열(argument)을 받을 때에는 배열의 개수가 0이 된다. Java에서는 배열의 개수가 없는 경우 0으로 나타난다.

---